From 114de116b3698e97cb10911c20f4ce1b72074e76 Mon Sep 17 00:00:00 2001
From: Stefan Markovic <stefan.markovic@rt-rk.com>
Date: Wed, 11 May 2016 11:15:38 +0200
Subject: [PATCH] Rebased MIPS cache model simulation on QEMU v2.5 stable and
 conflicts resolved. Fixed mips_cache_config() calling problem.

---
 include/qemu/log.h       |   10 +
 include/qemu/option.h    |   20 +
 qemu-log.c               |   43 +
 qemu-options.hx          |   19 +
 target-mips/cache_defs.h |  171 +++
 target-mips/cpu.c        |   14 +-
 target-mips/cpu.h        |   21 +
 target-mips/helper.c     |    2 +-
 target-mips/helper.h     |   12 +
 target-mips/op_helper.c  | 2691 ++++++++++++++++++++++++++++++++++++++++++++++
 target-mips/translate.c  |  830 +++++++++++++-
 ui/sdl.c                 |   33 +
 vl.c                     |  731 +++++++++++++
 13 files changed, 4575 insertions(+), 22 deletions(-)
 create mode 100644 target-mips/cache_defs.h

diff --git a/include/qemu/log.h b/include/qemu/log.h
index 362cbc4..231d053 100644
--- a/include/qemu/log.h
+++ b/include/qemu/log.h
@@ -14,6 +14,16 @@
 extern FILE *qemu_logfile;
 extern int qemu_loglevel;
 
+#define DEFAULT_CACHE_LOG_PATH ("/tmp/cache.log")
+#define DEFAULT_ICOUNT_LOG_PATH ("/tmp/icount.log")
+
+extern FILE *cache_logfile, *icount_logfile;
+extern char *cache_logfile_path, *icount_logfile_path;
+extern volatile int cache_log_on;
+extern int iteration_id;
+
+void cache_logfile_init(void);
+
 /* 
  * The new API:
  *
diff --git a/include/qemu/option.h b/include/qemu/option.h
index 71f5f27..7aea637 100644
--- a/include/qemu/option.h
+++ b/include/qemu/option.h
@@ -32,6 +32,26 @@
 #include "qapi/qmp/qdict.h"
 #include "qemu/typedefs.h"
 
+typedef struct cache_model_t {
+    uint32_t        enable;
+    uint32_t        ways;
+    uint32_t        sets;
+    uint32_t        linelength;
+    uint32_t        wback;
+    uint32_t        rdal;
+    uint32_t        wral;
+    uint32_t        alg;
+    uint32_t        type;
+    uint32_t        enops;
+
+} cache_model_t;
+
+extern cache_model_t l1dmodel;
+extern cache_model_t l1imodel;
+extern cache_model_t l2model;
+extern cache_model_t l3model;
+extern cache_model_t subsystem;
+
 const char *get_opt_name(char *buf, int buf_size, const char *p, char delim);
 const char *get_opt_value(char *buf, int buf_size, const char *p);
 int get_next_param_value(char *buf, int buf_size,
diff --git a/qemu-log.c b/qemu-log.c
index 7cb01a8..813a315 100644
--- a/qemu-log.c
+++ b/qemu-log.c
@@ -25,6 +25,49 @@ FILE *qemu_logfile;
 int qemu_loglevel;
 static int log_append = 0;
 
+FILE *cache_logfile, *icount_logfile;
+char *cache_logfile_path = NULL;
+char *icount_logfile_path = NULL;
+volatile int cache_log_on;
+int iteration_id = 0;
+extern int enable_mips_cache_model;
+extern int enable_mips_icount_stats;
+
+void cache_logfile_init(void)
+{
+    char *path = NULL;
+
+    if (enable_mips_cache_model) {
+        if (!cache_logfile_path) {
+            cache_logfile_path = strdup(DEFAULT_CACHE_LOG_PATH);
+        }
+
+        path = (char *) malloc(strlen(cache_logfile_path) + 10);
+        sprintf(path, "%s.%d", cache_logfile_path, iteration_id);
+        if ((cache_logfile = fopen(path, "w")) == NULL) {
+            fprintf(stderr, "Could not create %s log file!\n", path);
+            exit(1);
+        }
+        free(path);
+    }
+
+    if (enable_mips_icount_stats) {
+        if (!icount_logfile_path) {
+            icount_logfile_path = strdup(DEFAULT_ICOUNT_LOG_PATH);
+        }
+
+        path = (char *) malloc(strlen(icount_logfile_path) + 10);
+        sprintf(path, "%s.%d", icount_logfile_path, iteration_id);
+        if ((icount_logfile = fopen(path, "w")) == NULL) {
+            fprintf(stderr, "Could not create %s log file!\n", path);
+            exit(1);
+        }
+        free(path);
+    }
+
+    iteration_id++;
+}
+
 void qemu_log(const char *fmt, ...)
 {
     va_list ap;
diff --git a/qemu-options.hx b/qemu-options.hx
index 85a6cb8..ade83ff 100644
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -3683,6 +3683,25 @@ or Wireshark.
 ETEXI
 
 
+DEF("cache", HAS_ARG, QEMU_OPTION_cache,
+    "-cache lNmodel[,lNparam][,LNparam=value]\n"
+    "                Enable cache simulation.\n"
+    "                Use this option for applications profiling, and gather some statistical\n"
+    "                information about cache utilization.\n"
+    "                This option impacts performance significantly.\n"
+    "                Type -cache ? for available options and usage\n",
+    QEMU_ARCH_MIPS)
+STEXI
+ETEXI
+
+DEF("inscount", HAS_ARG, QEMU_OPTION_inscount,
+    "-inscount true[,icountlog=PATH] : Enable instruction count statistics.\n"
+    "                PATH should point to an existing directory.\n"
+    "                A file named icount.log will be created.\n",
+    QEMU_ARCH_MIPS)
+STEXI
+ETEXI
+
 HXCOMM This is the last statement. Insert new options before this line!
 STEXI
 @end table
diff --git a/target-mips/cache_defs.h b/target-mips/cache_defs.h
new file mode 100644
index 0000000..cb08db0
--- /dev/null
+++ b/target-mips/cache_defs.h
@@ -0,0 +1,171 @@
+#ifndef __CACHE_DEFS__
+#define __CACHE_DEFS__
+
+// Flag bits
+#define MIPS_CACHE_FLAG_VALID  (1<<0)
+#define MIPS_CACHE_FLAG_DIRTY  (1<<1)
+#define MIPS_CACHE_FLAG_LOCK   (1<<2)
+#define MIPS_CACHE_FLAG_READ   (1<<3)
+#define MIPS_CACHE_FLAG_GLOBAL (1<<4)
+#define MIPS_CACHE_FLAG_RETAIN (1<<5)
+
+// Cache type bits
+#define MIPS_CACHE_TYPE_VIPT     (1<<0)
+#define MIPS_CACHE_TYPE_VIVT     (1<<1)
+#define MIPS_CACHE_TYPE_PIPT     (1<<2)
+#define MIPS_CACHE_TYPE_RANDOM   (1<<3)
+#define MIPS_CACHE_TYPE_ROBIN    (1<<4)
+#define MIPS_CACHE_TYPE_LRU      (1<<5)
+#define MIPS_CACHE_TYPE_RDAL     (1<<6)
+#define MIPS_CACHE_TYPE_WRAL     (1<<7)
+#define MIPS_CACHE_TYPE_WTHRU    (1<<8)
+#define MIPS_CACHE_TYPE_WBACK    (1<<9)
+#define MIPS_CACHE_TYPE_WIGNORE  (1<<10)
+#define MIPS_CACHE_TYPE_USE_ASID (1<<11)
+#define MIPS_CACHE_TYPE_L2TLB    (1<<12)
+#define MIPS_CACHE_TYPE_EN_OPS   (1<<13)
+#define MIPS_CACHE_TYPE_SHARE    (1<<14)
+#define MIPS_CACHE_TYPE_NMRU4    (1<<15)
+#define MIPS_CACHE_TYPE_NMRU8    (1<<16)
+#define MIPS_CACHE_TYPE_PASS_K   (1<<17)
+#define MIPS_CACHE_TYPE_PASS_K1  (1<<18)
+#define MIPS_CACHE_TYPE_ORUN_2X2 (1<<19)
+#define MIPS_CACHE_TYPE_ORUN_2X4 (1<<20)
+#define MIPS_CACHE_TYPE_ASID_IN_KSEG (1<<21)
+
+// Cacheable segment bits
+#define MIPS_CACHE_MEM_KUSEG    (0x0f<<24)
+#define MIPS_CACHE_MEM_KSEG0    (0x10<<24)
+#define MIPS_CACHE_MEM_KSEG1    (0x20<<24)
+#define MIPS_CACHE_MEM_KSEG2    (0xc0<<24)
+#define MIPS_CACHE_MEM_ALL      (0xff<<24)
+
+// Possible commands
+#define MIPS_CACHE_READ                 0
+#define MIPS_CACHE_WRITE                1
+#define MIPS_CACHE_PREFETCH             2
+#define MIPS_CACHE_FLUSH_INV            3
+#define MIPS_CACHE_FLUSH                4
+#define MIPS_CACHE_INVALIDATE           5
+#define MIPS_CACHE_L2_READ              6
+#define MIPS_CACHE_INDEX_INVALIDATE     7
+#define MIPS_CACHE_INDEX_WB_INVALIDATE  8
+#define MIPS_CACHE_PREFETCH_RETAINED    9
+#define MIPS_CACHE_PREFETCH_FOR_WRITE   10
+#define MIPS_CACHE_FETCH_AND_LOCK       11
+
+#define TLB_EVEN 1
+#define TLB_ODD  2
+
+#define MCASID (env->CP0_EntryHi&0xFF)
+#define T0 (env_ptr->active_tc.gpr[8])
+#define T1 (env_ptr->active_tc.gpr[9])
+#define T2 (env_ptr->active_tc.gpr[10])
+
+#define DCAX(type,size,addr) do {                           \
+    if (enable_mips_cache_model)                            \
+        gen_helper_mips_dc_access(cpu_env,type,size,addr);  \
+} while(0)
+
+extern int enable_mips_cache_model;
+extern int enable_mips_icount_stats;
+
+#define CACHE_MODEL_ENABLED() do {  \
+    if (!cache_log_on) return;      \
+} while(0)
+
+struct CPUMIPSState;
+typedef struct CPUMIPSState CPUMIPSState;
+
+typedef struct mips_cache_t mips_cache_t;
+struct mips_cache_t {
+
+    // Basic parameters
+    uint64_t        time;
+    uint64_t        *timeptr;
+    uint32_t        ways;
+    uint32_t        sets;
+    uint32_t        linelength;
+    uint32_t        type;
+    uint32_t        samelinemask;
+    uint32_t        hit_time;
+
+    // Array pointers
+    uint32_t        *vasid;
+    target_ulong    *vtags;              // tag array  - tag[way][set]
+    target_ulong    *ptags;              // tag array  - tag[way][set]
+    uint32_t        *flags;              //
+    uint64_t        *times;              // LRU/NMRU timestamp
+
+    // Stats
+    uint64_t        reads;
+    uint64_t        writes;
+    uint64_t        prefetch;
+    uint64_t        read_hit;
+    uint64_t        ins_read_hit;
+    uint64_t        read_miss;
+    uint64_t        ins_read_miss;
+    uint64_t        write_hit;
+    uint64_t        write_miss;
+    uint64_t        prefetch_hit;
+    uint64_t        read_allocate;
+    uint64_t        write_allocate;
+    uint64_t        prefetch_allocate;
+    uint64_t        prefetch_for_write;
+    uint64_t        prefetch_for_write_hit;
+    uint64_t        prefetch_for_write_miss;
+    uint64_t        prefetch_for_write_allocate;
+    uint64_t        fetch_locks;
+    uint64_t        fetch_lock_hit;
+    uint64_t        fetch_lock_allocate;
+    uint64_t        read_passthrough;
+    uint64_t        write_passthrough;
+    uint64_t        replace_clean_was_read;
+    uint64_t        replace_clean_never_read;
+    uint64_t        replace_dirty_was_read;
+    uint64_t        replace_dirty_never_read;
+    uint64_t        flush;
+    uint64_t        invalidate;
+    uint64_t        flush_inv;
+    uint64_t        flush_hit;
+    uint64_t        inv_hit;
+    uint64_t        flush_inv_hit;
+
+    // Pointer to the next level down
+    mips_cache_t    *next_level;
+
+    //  These only used during setup with mips_cache_config()
+    char            next[8];
+    char            share[8];
+
+    // Name
+    char            name[80];
+
+};
+
+mips_cache_t *mips_cache_init(uint32_t ways, uint32_t sets, uint32_t linelength,
+                              uint32_t type, uint32_t hit_time, const char *name);
+void mips_cache_free(mips_cache_t *c);
+void mips_cache_config(CPUMIPSState *env);
+void mips_cache_report_logfile(FILE *file, mips_cache_t *c);
+void mips_cache_results_to_logfile(CPUMIPSState *env);
+void dump_instruction_stats(CPUMIPSState *env);
+char const *decode_icount_index(int index);
+void reset_instruction_counters(CPUMIPSState *env);
+void do_icache_per_instruction(CPUMIPSState *env, target_ulong addr);
+void do_instruction_count(CPUMIPSState *env, uint32_t opcode);
+target_ulong r4k_get_phys_addr (CPUMIPSState *env, target_ulong va, int cmd, int *success);
+int get_physical_address (CPUMIPSState *env, hwaddr *physical,
+                                int *prot, target_ulong address,
+                                int rw, int access_type);
+void mips_cache_access( CPUMIPSState *env,
+                        mips_cache_t *c,        // Cache structure
+                        uint32_t asid,
+                        target_ulong va,        // Virtual address
+                        target_ulong pa,        // Physical address
+                        uint32_t cmd,           // Command
+                        uint32_t size,          // Size of transaction (unused at present)
+						uint32_t seq,           // Number of sequential transactions (within same line)
+                        uint32_t access_type);  // Type of cache access, instruction (1)/data (0)
+
+#endif
\ No newline at end of file
diff --git a/target-mips/cpu.c b/target-mips/cpu.c
index 639a24b..7eb8057 100644
--- a/target-mips/cpu.c
+++ b/target-mips/cpu.c
@@ -22,7 +22,10 @@
 #include "kvm_mips.h"
 #include "qemu-common.h"
 #include "sysemu/kvm.h"
-
+#include <stdio.h>
+ 
+CPUMIPSState *env_ptr;
+ 
 
 static void mips_cpu_set_pc(CPUState *cs, vaddr value)
 {
@@ -86,18 +89,27 @@ static void mips_cpu_reset(CPUState *s)
     MIPSCPUClass *mcc = MIPS_CPU_GET_CLASS(cpu);
     CPUMIPSState *env = &cpu->env;
 
+    static int do_cache_config = 1;
+
     mcc->parent_reset(s);
 
     memset(env, 0, offsetof(CPUMIPSState, mvp));
     tlb_flush(s, 1);
 
     cpu_state_reset(env);
+    
+    
+    if(do_cache_config == 2){
+        env_ptr = env;
+        mips_cache_config(env);
+    }
 
 #ifndef CONFIG_USER_ONLY
     if (kvm_enabled()) {
         kvm_mips_reset_vcpu(cpu);
     }
 #endif
+            do_cache_config++;
 }
 
 static void mips_cpu_disas_set_info(CPUState *s, disassemble_info *info) {
diff --git a/target-mips/cpu.h b/target-mips/cpu.h
index 89c01f7..c169253 100644
--- a/target-mips/cpu.h
+++ b/target-mips/cpu.h
@@ -12,6 +12,7 @@
 #include "mips-defs.h"
 #include "exec/cpu-defs.h"
 #include "fpu/softfloat.h"
+#include "cache_defs.h"
 
 struct CPUMIPSState;
 
@@ -52,6 +53,13 @@ struct CPUMIPSTLBContext {
             r4k_tlb_t tlb[MIPS_TLB_MAX];
         } r4k;
     } mmu;
+
+    uint64_t tlb_accesses;
+    uint64_t tlb_hit;
+    uint64_t tlb_miss;
+    uint64_t tlb_dirty;
+    uint64_t tlb_invalid;
+    uint64_t tlb_bad_address;
 };
 #endif
 
@@ -214,6 +222,7 @@ struct TCState {
 };
 
 typedef struct CPUMIPSState CPUMIPSState;
+extern CPUMIPSState *env_ptr;
 struct CPUMIPSState {
     TCState active_tc;
     CPUMIPSFPUContext active_fpu;
@@ -585,6 +594,18 @@ struct CPUMIPSState {
     int insn_flags; /* Supported instruction set */
 
     CPU_COMMON
+ 
+    target_ulong IR;    /* Instruction register emulation, holds 4
+                           successive instructions */
+
+    mips_cache_t *imodel;
+    mips_cache_t *dmodel;
+    mips_cache_t *l2model;
+    mips_cache_t *l3model;
+    mips_cache_t *subsystem;
+
+    uint64_t icount[500];
+    uint64_t invalid_opc;
 
     /* Fields from here on are preserved across CPU reset. */
     CPUMIPSMVPContext *mvp;
diff --git a/target-mips/helper.c b/target-mips/helper.c
index 118072a..07bed86 100644
--- a/target-mips/helper.c
+++ b/target-mips/helper.c
@@ -109,7 +109,7 @@ int r4k_map_address (CPUMIPSState *env, hwaddr *physical, int *prot,
     return TLBRET_NOMATCH;
 }
 
-static int get_physical_address (CPUMIPSState *env, hwaddr *physical,
+int get_physical_address (CPUMIPSState *env, hwaddr *physical,
                                 int *prot, target_ulong real_address,
                                 int rw, int access_type)
 {
diff --git a/target-mips/helper.h b/target-mips/helper.h
index 95b9149..39eab00 100644
--- a/target-mips/helper.h
+++ b/target-mips/helper.h
@@ -1,3 +1,15 @@
+DEF_HELPER_1(cache_log_toggle_on, void, env)
+DEF_HELPER_1(cache_log_toggle_off, void, env)
+
+DEF_HELPER_2(instruction_count, void, env, i32)
+DEF_HELPER_2(cache_op, void, env, i32)
+DEF_HELPER_2(prefetch_op, void, env, i32)
+DEF_HELPER_2(synci_op, void, env, i32)
+DEF_HELPER_2(icache_per_instruction, void, env, tl)
+
+DEF_HELPER_4(mips_dc_access, void, env, i32, i32, tl)
+
+
 DEF_HELPER_3(raise_exception_err, noreturn, env, i32, int)
 DEF_HELPER_2(raise_exception, noreturn, env, i32)
 DEF_HELPER_1(raise_exception_debug, noreturn, env)
diff --git a/target-mips/op_helper.c b/target-mips/op_helper.c
index d2c98c9..3e31752 100644
--- a/target-mips/op_helper.c
+++ b/target-mips/op_helper.c
@@ -22,6 +22,2697 @@
 #include "exec/helper-proto.h"
 #include "exec/cpu_ldst.h"
 #include "sysemu/kvm.h"
+#include "cache_defs.h"
+#include <math.h>
+ 
+int enable_mips_cache_model = 0;
+int enable_mips_icount_stats = 0;
+
+static inline void mips_cache_reset_stats(CPUMIPSState *env);
+
+mips_cache_t *mips_cache_init(uint32_t ways, uint32_t sets, uint32_t linelength,
+                              uint32_t type, uint32_t hit_time, const char *name)
+{
+    mips_cache_t *c;
+    target_ulong size;
+
+#ifdef CACHE_DEBUG
+    fprintf(cache_logfile,"%s : %s - ways=%d, sets=%d, ll=%d, type=0x%08x -> %d bytes\n",
+            __func__,name,ways,sets,linelength,type,ways*sets*linelength);
+#endif
+
+    // Set random seed
+    srand(0);
+
+    // Size
+    size = ways * sets * linelength;
+
+    // Allocate memory for cache structure
+    c = (mips_cache_t*) calloc(sizeof(mips_cache_t),1);
+    if (!c) return(NULL);
+
+    if (size) {
+        // Allocate memory for tag arrays
+        c->vasid = (uint32_t*) calloc(ways * sets * sizeof(uint32_t),1);
+        if (!c->vasid) return(NULL);
+        c->vtags = (target_ulong*) calloc(ways * sets * sizeof(target_ulong),1);
+        if (!c->vtags) return(NULL);
+        c->ptags = (target_ulong*) calloc(ways * sets * sizeof(target_ulong),1);
+        if (!c->ptags) return(NULL);
+
+        // Allocate memory for flags
+        c->flags = (uint32_t*) calloc(ways * sets * sizeof(uint32_t),1);
+        if (!c->flags) return(NULL);
+
+        // Allocate memory for LRU timestamp / NMRU indexes
+        c->times = (uint64_t*) calloc(ways * sets * sizeof(uint64_t),1);
+        if (!c->times) return(NULL);
+
+        // All flags, tags and times will be zero
+    }
+
+    // Set up basic parameters
+    c->time = 0;
+    c->timeptr = &(c->time);
+    c->ways = ways;
+    c->sets = sets;
+    c->linelength = linelength;
+    c->samelinemask = ~(linelength-1);
+    c->type = type;
+    c->hit_time = hit_time;
+
+    // Name
+    strncpy(c->name,name,79);
+    c->name[79]=0;
+
+    // Return pointer
+    return(c);
+}
+
+/* Free memory associated with cache model
+ */
+void mips_cache_free(mips_cache_t *c)
+{
+    if (c) {
+        if (c->times) free(c->times);
+        if (c->flags) free(c->flags);
+        if (c->ptags) free(c->ptags);
+        if (c->vtags) free(c->vtags);
+        if (c->vasid) free(c->vasid);
+        free(c);
+    }
+}
+
+void mips_cache_report_logfile(FILE *file, mips_cache_t *c)
+{
+    // No file - return
+    if (!(file)) return;
+    if (c == NULL) return;
+
+    // Name, size, configuration
+    fprintf(file,"Name     : %s\n",c->name);
+    fprintf(file,"Ways     : %d\n",c->ways);
+    fprintf(file,"Sets     : %d\n",c->sets);
+    fprintf(file,"Line     : %d\n",c->linelength);
+    fprintf(file,"Size     : %d\n",c->sets*c->ways*c->linelength);
+
+    // Type flags
+    fprintf(file,"Flags    : \n");
+    if (c->type & MIPS_CACHE_TYPE_VIPT)     fprintf(file,"            VIPT     - Virtually indexed, physically tagged\n");
+    if (c->type & MIPS_CACHE_TYPE_VIVT)     fprintf(file,"            VIVT     - Virtually indexed, virtually tagged\n");
+    if (c->type & MIPS_CACHE_TYPE_PIPT)     fprintf(file,"            PIPT     - Physically indexed, physically tagged\n");
+    if (c->type & MIPS_CACHE_TYPE_RANDOM)   fprintf(file,"            RANDOM   - Random replacement\n");
+    if (c->type & MIPS_CACHE_TYPE_ROBIN)    fprintf(file,"            ROBIN    - Round robin replacement, per set\n");
+    if (c->type & MIPS_CACHE_TYPE_LRU)      fprintf(file,"            LRU      - Least recently used replacement, per set\n");
+    if (c->type & MIPS_CACHE_TYPE_NMRU4)    fprintf(file,"            NMRU4    - Not the most recently used 4, per set\n");
+    if (c->type & MIPS_CACHE_TYPE_NMRU8)    fprintf(file,"            NMRU8    - Not the most recently used 8, per set\n");
+    if (c->type & MIPS_CACHE_TYPE_RDAL)     fprintf(file,"            RDAL     - Allocate on read miss\n");
+    if (c->type & MIPS_CACHE_TYPE_WRAL)     fprintf(file,"            WRAL     - Allocate on write miss\n");
+    if (c->type & MIPS_CACHE_TYPE_WTHRU)    fprintf(file,"            WTHRU    - Write through - passed to next level\n");
+    if (c->type & MIPS_CACHE_TYPE_WBACK)    fprintf(file,"            WBACK    - Write back - valid line set dirty\n");
+    if (c->type & MIPS_CACHE_TYPE_WIGNORE)  fprintf(file,"            WIGNORE  - Writes are ignored\n");
+    if (c->type & MIPS_CACHE_TYPE_USE_ASID) fprintf(file,"            USE_ASID - Use ASID in tag comparison\n");
+    if (c->type & MIPS_CACHE_TYPE_L2TLB)    fprintf(file,"            L2TLB    - Look up once per physical address in TLB pair\n");
+    if (c->type & MIPS_CACHE_TYPE_EN_OPS)   fprintf(file,"            EN_OPS   - Enable cache and prefetch operations\n");
+    if (c->type & MIPS_CACHE_TYPE_SHARE)    fprintf(file,"            SHARE    - Using another block's tables\n");
+    if (c->type & MIPS_CACHE_TYPE_PASS_K)   fprintf(file,"            PASS_K   - Uncached access to KSEG0,KSEG1,KSEG2\n");
+    if (c->type & MIPS_CACHE_TYPE_PASS_K1)  fprintf(file,"            PASS_K1  - Uncached access to KSEG1\n");
+    if (c->type & MIPS_CACHE_TYPE_ORUN_2X2) fprintf(file,"            ORUN_2X2 - Model overrun by 2 x 64-bit bundles on flow change\n");
+    if (c->type & MIPS_CACHE_TYPE_ORUN_2X4) fprintf(file,"            ORUN_2X4 - Model overrun by 2 x 128-bit bundles on flow change\n");
+    if (c->type & MIPS_CACHE_TYPE_ASID_IN_KSEG) fprintf(file,"            KSEG_ASID - ASID is (erroneously) considered in kseg0/1 lookups - for 74k bug\n");
+
+    // Memory
+    fprintf(file,"Mem      : ");
+    if (c->type & MIPS_CACHE_MEM_KUSEG) fprintf(file,"kuseg, ");
+    if (c->type & MIPS_CACHE_MEM_KSEG0) fprintf(file,"kseg0, ");
+    if (c->type & MIPS_CACHE_MEM_KSEG1) fprintf(file,"kseg1, ");
+    if (c->type & MIPS_CACHE_MEM_KSEG2) fprintf(file,"kseg2");
+    fprintf(file,"\n");
+
+    fprintf(file,"Next     : ");
+    if (c->next_level == NULL) fprintf(file,"None\n");
+    else                       fprintf(file,"%s\n",c->next_level->name);
+    fprintf(file,"\n");
+}
+
+void mips_cache_config(CPUMIPSState *env)
+{
+    uint32_t        ways;
+    uint32_t        sets;
+    uint32_t        linelength;
+    uint32_t        type;
+    static int a = 0;
+    env->imodel = NULL;
+    env->dmodel = NULL;
+    env->l2model = NULL;
+    env->l3model = NULL;
+    env->subsystem = NULL;
+
+    env->subsystem = mips_cache_init(0, 0, 0, 0, 100, "subsystem");
+
+    if (l1imodel.enable) {
+        ways = l1imodel.ways;
+        sets = l1imodel.sets;
+        linelength = l1imodel.linelength;
+
+        type = 0;
+        type |= l1imodel.rdal ? MIPS_CACHE_TYPE_RDAL : 0;
+        type |= l1imodel.wral ? MIPS_CACHE_TYPE_WRAL : 0;
+        type |= l1imodel.enops ? MIPS_CACHE_TYPE_EN_OPS : 0;
+        type |= MIPS_CACHE_TYPE_PASS_K1;
+
+        switch(l1imodel.type) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_VIPT;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_VIVT;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_PIPT;
+                break;
+            default:
+                fprintf(stderr, "Illegal cache type!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        switch(l1imodel.alg) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_LRU;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_ROBIN;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_RANDOM;
+                break;
+            case 4:
+                type |= MIPS_CACHE_TYPE_NMRU4;
+                break;
+            case 5:
+                type |= MIPS_CACHE_TYPE_NMRU8;
+                break;
+            default :
+                fprintf(stderr, "Illegal victim selection algorithm!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        env->imodel = mips_cache_init(ways, sets, linelength, type, 1, "L1-icache");
+        env->imodel->next_level = env->subsystem;
+        fflush(stdout);
+    }
+
+    if (l1dmodel.enable) {
+        ways = l1dmodel.ways;
+        sets = l1dmodel.sets;
+        linelength = l1dmodel.linelength;
+
+        type = 0;
+        type |= l1dmodel.rdal ? MIPS_CACHE_TYPE_RDAL : 0;
+        type |= l1dmodel.wral ? MIPS_CACHE_TYPE_WRAL : 0;
+        type |= l1dmodel.wback ? MIPS_CACHE_TYPE_WBACK : MIPS_CACHE_TYPE_WTHRU;
+        type |= l1dmodel.enops ? MIPS_CACHE_TYPE_EN_OPS : 0;
+        type |= MIPS_CACHE_TYPE_PASS_K1;
+
+        switch(l1dmodel.type) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_VIPT;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_VIVT;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_PIPT;
+                break;
+            default:
+                fprintf(stderr, "Illegal cache type!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        switch(l1dmodel.alg) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_LRU;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_ROBIN;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_RANDOM;
+                break;
+            case 4:
+                type |= MIPS_CACHE_TYPE_NMRU4;
+                break;
+            case 5:
+                type |= MIPS_CACHE_TYPE_NMRU8;
+                break;
+            default :
+                fprintf(stderr, "Illegal victim selection algorithm!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        env->dmodel = mips_cache_init(ways, sets, linelength, type, 1, "L1-dcache");
+        env->dmodel->next_level = env->subsystem;
+    }
+
+    if (l2model.enable) {
+        ways = l2model.ways;
+        sets = l2model.sets;
+        linelength = l2model.linelength;
+
+        type = 0;
+        type |= l2model.rdal ? MIPS_CACHE_TYPE_RDAL : 0;
+        type |= l2model.wral ? MIPS_CACHE_TYPE_WRAL : 0;
+        type |= l2model.wback ? MIPS_CACHE_TYPE_WBACK : MIPS_CACHE_TYPE_WTHRU;
+        type |= l2model.enops ? MIPS_CACHE_TYPE_EN_OPS : 0;
+        type |= MIPS_CACHE_TYPE_PASS_K1;
+
+        switch(l2model.type) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_VIPT;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_VIVT;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_PIPT;
+                break;
+            default:
+                fprintf(stderr, "Illegal cache type!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        switch(l2model.alg) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_LRU;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_ROBIN;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_RANDOM;
+                break;
+            case 4:
+                type |= MIPS_CACHE_TYPE_NMRU4;
+                break;
+            case 5:
+                type |= MIPS_CACHE_TYPE_NMRU8;
+                break;
+            default :
+                fprintf(stderr, "Illegal victim selection algorithm!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        if (l1imodel.enable || l1dmodel.enable) {
+            env->l2model = mips_cache_init(ways, sets, linelength, type, 10, "L2-cache");
+            if (l1imodel.enable)
+                env->imodel->next_level = env->l2model;
+            if (l1dmodel.enable)
+                env->dmodel->next_level = env->l2model;
+            env->l2model->next_level = env->subsystem;
+        } else {
+            fprintf(stderr, "L1 cache level must be enabled for L2 to be configured\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    if (l3model.enable) {
+        ways = l3model.ways;
+        sets = l3model.sets;
+        linelength = l3model.linelength;
+
+        type = 0;
+        type |= l3model.rdal ? MIPS_CACHE_TYPE_RDAL : 0;
+        type |= l3model.wral ? MIPS_CACHE_TYPE_WRAL : 0;
+        type |= l3model.wback ? MIPS_CACHE_TYPE_WBACK : MIPS_CACHE_TYPE_WTHRU;
+        type |= l3model.enops ? MIPS_CACHE_TYPE_EN_OPS : 0;
+        type |= MIPS_CACHE_TYPE_PASS_K1;
+
+        switch(l3model.type) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_VIPT;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_VIVT;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_PIPT;
+                break;
+            default:
+                fprintf(stderr, "Illegal cache type!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        switch(l3model.alg) {
+            case 1:
+                type |= MIPS_CACHE_TYPE_LRU;
+                break;
+            case 2:
+                type |= MIPS_CACHE_TYPE_ROBIN;
+                break;
+            case 3:
+                type |= MIPS_CACHE_TYPE_RANDOM;
+                break;
+            case 4:
+                type |= MIPS_CACHE_TYPE_NMRU4;
+                break;
+            case 5:
+                type |= MIPS_CACHE_TYPE_NMRU8;
+                break;
+            default :
+                fprintf(stderr, "Illegal victim selection algorithm!\n");
+                exit(EXIT_FAILURE);
+        }
+
+        if (l2model.enable) {
+            env->l3model = mips_cache_init(ways, sets, linelength, type, 10, "L3-cache");
+            env->l2model->next_level = env->l3model;
+            env->l3model->next_level = env->subsystem;
+        } else {
+            fprintf(stderr, "L2 level must be enabled first for L3 to be configured!\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    if (l1imodel.enable) mips_cache_report_logfile(stderr, env->imodel);
+    if (l1dmodel.enable) mips_cache_report_logfile(stderr, env->dmodel);
+    if (l2model.enable) mips_cache_report_logfile(stderr, env->l2model);
+    if (l3model.enable) mips_cache_report_logfile(stderr, env->l3model);
+
+    mips_cache_reset_stats(env);
+}
+
+static double mips_cache_miss_rate(mips_cache_t *c)
+{
+    double miss_rate = 0.0;
+
+    if (c) {
+        if (strcmp("subsystem", c->name) == 0) {
+            return miss_rate;
+        } else {
+            miss_rate = (double)(c->read_miss + c->write_miss) /
+                        (double)(c->reads + c->writes);
+            return miss_rate;
+        }
+    }
+
+    return -1.0;
+}
+
+void mips_cache_results_to_logfile(CPUMIPSState *env)
+{
+    fprintf(cache_logfile, "============================================"
+                           "============================================\n"
+                           "CACHE STATS\n"
+                           "============================================"
+                           "============================================\n");
+    //printf("%d ADRESA 2 \n", env->imodel);
+    if (env->imodel) {
+        fprintf(cache_logfile, "Level : %s\n", env->imodel->name);
+        fprintf(cache_logfile, "      Reads :               %16" PRId64 "", env->imodel->reads);
+        fprintf(cache_logfile, "      Writes :              %16" PRId64 "\n", env->imodel->writes);
+        fprintf(cache_logfile, "      Read hits :           %16" PRId64 "", env->imodel->read_hit);
+        fprintf(cache_logfile, "      Write hits :          %16" PRId64 "\n", env->imodel->write_hit);
+        fprintf(cache_logfile, "      Read misses :         %16" PRId64 "", env->imodel->read_miss);
+        fprintf(cache_logfile, "      Write misses :        %16" PRId64 "\n\n", env->imodel->write_miss);
+        fprintf(cache_logfile, "      Fetch Locks :         %16" PRId64 "", env->imodel->fetch_locks);
+        fprintf(cache_logfile, "      Flushes :             %16" PRId64 "\n", env->imodel->flush);
+        fprintf(cache_logfile, "      Fetch Lock hits :     %16" PRId64 "", env->imodel->fetch_lock_hit);
+        fprintf(cache_logfile, "      Flush hits  :         %16" PRId64 "\n", env->imodel->flush_hit);
+        fprintf(cache_logfile, "      Flush Invalidates:    %16" PRId64 "", env->imodel->flush_inv);
+        fprintf(cache_logfile, "      Flush Invalidate hits:%16" PRId64 "\n", env->imodel->flush_inv_hit);
+        fprintf(cache_logfile, "      Hit Invalidates :     %16" PRId64 "", env->imodel->invalidate);
+        fprintf(cache_logfile, "      Hit Invalidate hits : %16" PRId64 "\n", env->imodel->inv_hit);
+        fprintf(cache_logfile, "      Dirty read victim:    %16" PRId64 "", env->imodel->replace_dirty_was_read);
+        fprintf(cache_logfile, "      Dirty not read victim:%16" PRId64 "\n", env->imodel->replace_dirty_never_read);
+        fprintf(cache_logfile, "      Clean read victim:    %16" PRId64 "", env->imodel->replace_clean_was_read);
+        fprintf(cache_logfile, "      Clean not read victim:%16" PRId64 "\n\n", env->imodel->replace_clean_never_read);
+        fprintf(cache_logfile, "      Miss rate :           %16.3lf\n\n", mips_cache_miss_rate(env->imodel));
+        fprintf(cache_logfile, "--------------------------------------------"
+                               "--------------------------------------------\n");
+    }
+
+    if (env->dmodel) {
+        fprintf(cache_logfile, "Level : %s\n", env->dmodel->name);
+        fprintf(cache_logfile, "      Reads :               %16" PRId64 "", env->dmodel->reads);
+        fprintf(cache_logfile, "      Writes :              %16" PRId64 "\n", env->dmodel->writes);
+        fprintf(cache_logfile, "      Read hits :           %16" PRId64 "", env->dmodel->read_hit);
+        fprintf(cache_logfile, "      Write hits :          %16" PRId64 "\n", env->dmodel->write_hit);
+        fprintf(cache_logfile, "      Read misses :         %16" PRId64 "", env->dmodel->read_miss);
+        fprintf(cache_logfile, "      Write misses :        %16" PRId64 "\n\n", env->dmodel->write_miss);
+        fprintf(cache_logfile, "      Prefetches :          %16" PRId64 "", env->dmodel->prefetch);
+        fprintf(cache_logfile, "      Prefetches for write :%16" PRId64 "\n", env->dmodel->prefetch_for_write);
+        fprintf(cache_logfile, "      Prefetch hits :       %16" PRId64 "", env->dmodel->prefetch_hit);
+        fprintf(cache_logfile, "      Prefetch write hits : %16" PRId64 "\n\n", env->dmodel->prefetch_for_write_hit);
+        fprintf(cache_logfile, "      Fetch Locks :         %16" PRId64 "", env->dmodel->fetch_locks);
+        fprintf(cache_logfile, "      Flushes :             %16" PRId64 "\n", env->dmodel->flush);
+        fprintf(cache_logfile, "      Fetch Lock hits :     %16" PRId64 "", env->dmodel->fetch_lock_hit);
+        fprintf(cache_logfile, "      Flush hits  :         %16" PRId64 "\n", env->dmodel->flush_hit);
+        fprintf(cache_logfile, "      Flush Invalidates:    %16" PRId64 "", env->dmodel->flush_inv);
+        fprintf(cache_logfile, "      Flush Invalidate hits:%16" PRId64 "\n", env->dmodel->flush_inv_hit);
+        fprintf(cache_logfile, "      Hit Invalidates :     %16" PRId64 "", env->dmodel->invalidate);
+        fprintf(cache_logfile, "      Hit Invalidate hits : %16" PRId64 "\n", env->dmodel->inv_hit);
+        fprintf(cache_logfile, "      Dirty read victim:    %16" PRId64 "", env->dmodel->replace_dirty_was_read);
+        fprintf(cache_logfile, "      Dirty not read victim:%16" PRId64 "\n", env->dmodel->replace_dirty_never_read);
+        fprintf(cache_logfile, "      Clean read victim:    %16" PRId64 "", env->dmodel->replace_clean_was_read);
+        fprintf(cache_logfile, "      Clean not read victim:%16" PRId64 "\n\n", env->dmodel->replace_clean_never_read);
+        fprintf(cache_logfile, "      Miss rate :           %16.3lf\n\n", mips_cache_miss_rate(env->dmodel));
+        fprintf(cache_logfile, "--------------------------------------------"
+                               "--------------------------------------------\n");
+    }
+
+    if (env->l2model) {
+        fprintf(cache_logfile, "Level : %s\n", env->l2model->name);
+        fprintf(cache_logfile, "      Reads :               %16" PRId64 "", env->l2model->reads);
+        fprintf(cache_logfile, "      Writes :              %16" PRId64 "\n", env->l2model->writes);
+        fprintf(cache_logfile, "      Read hits :           %16" PRId64 "", env->l2model->read_hit);
+        fprintf(cache_logfile, "      Write hits :          %16" PRId64 "\n", env->l2model->write_hit);
+        fprintf(cache_logfile, "      Read misses :         %16" PRId64 "", env->l2model->read_miss);
+        fprintf(cache_logfile, "      Write misses :        %16" PRId64 "\n", env->l2model->write_miss);
+        fprintf(cache_logfile, "      Inst. read hits :     %16" PRId64 "\n", env->l2model->ins_read_hit);
+        fprintf(cache_logfile, "      Inst. read misses :   %16" PRId64 "\n\n", env->l2model->ins_read_miss);
+        fprintf(cache_logfile, "      Prefetches :          %16" PRId64 "", env->l2model->prefetch);
+        fprintf(cache_logfile, "      Prefetches for write :%16" PRId64 "\n", env->l2model->prefetch_for_write);
+        fprintf(cache_logfile, "      Prefetch hits :       %16" PRId64 "", env->l2model->prefetch_hit);
+        fprintf(cache_logfile, "      Prefetch write hits : %16" PRId64 "\n\n", env->l2model->prefetch_for_write_hit);
+        fprintf(cache_logfile, "      Fetch Locks :         %16" PRId64 "", env->l2model->fetch_locks);
+        fprintf(cache_logfile, "      Flushes :             %16" PRId64 "\n", env->l2model->flush);
+        fprintf(cache_logfile, "      Fetch Lock hits :     %16" PRId64 "", env->l2model->fetch_lock_hit);
+        fprintf(cache_logfile, "      Flush hits  :         %16" PRId64 "\n", env->l2model->flush_hit);
+        fprintf(cache_logfile, "      Flush Invalidates:    %16" PRId64 "", env->l2model->flush_inv);
+        fprintf(cache_logfile, "      Flush Invalidate hits:%16" PRId64 "\n", env->l2model->flush_inv_hit);
+        fprintf(cache_logfile, "      Hit Invalidates :     %16" PRId64 "", env->l2model->invalidate);
+        fprintf(cache_logfile, "      Hit Invalidate hits : %16" PRId64 "\n", env->l2model->inv_hit);
+        fprintf(cache_logfile, "      Dirty read victim:    %16" PRId64 "", env->l2model->replace_dirty_was_read);
+        fprintf(cache_logfile, "      Dirty not read victim:%16" PRId64 "\n", env->l2model->replace_dirty_never_read);
+        fprintf(cache_logfile, "      Clean read victim:    %16" PRId64 "", env->l2model->replace_clean_was_read);
+        fprintf(cache_logfile, "      Clean not read victim:%16" PRId64 "\n\n", env->l2model->replace_clean_never_read);
+        fprintf(cache_logfile, "      Miss rate :           %16.3lf\n\n", mips_cache_miss_rate(env->l2model));
+        fprintf(cache_logfile, "--------------------------------------------"
+                               "--------------------------------------------\n");
+    }
+
+    if (env->l3model) {
+        fprintf(cache_logfile, "Level : %s\n", env->l3model->name);
+        fprintf(cache_logfile, "      Reads :               %16" PRId64 "", env->l3model->reads);
+        fprintf(cache_logfile, "      Writes :              %16" PRId64 "\n", env->l3model->writes);
+        fprintf(cache_logfile, "      Read hits :           %16" PRId64 "", env->l3model->read_hit);
+        fprintf(cache_logfile, "      Write hits :          %16" PRId64 "\n", env->l3model->write_hit);
+        fprintf(cache_logfile, "      Read misses :         %16" PRId64 "", env->l3model->read_miss);
+        fprintf(cache_logfile, "      Write misses :        %16" PRId64 "\n", env->l3model->write_miss);
+        fprintf(cache_logfile, "      Inst. read hits :     %16" PRId64 "\n", env->l3model->ins_read_hit);
+        fprintf(cache_logfile, "      Inst. read misses :   %16" PRId64 "\n\n", env->l3model->ins_read_miss);
+        fprintf(cache_logfile, "      Prefetches :          %16" PRId64 "", env->l3model->prefetch);
+        fprintf(cache_logfile, "      Prefetches for write :%16" PRId64 "\n", env->l3model->prefetch_for_write);
+        fprintf(cache_logfile, "      Prefetch hits :       %16" PRId64 "", env->l3model->prefetch_hit);
+        fprintf(cache_logfile, "      Prefetch write hits : %16" PRId64 "\n\n", env->l3model->prefetch_for_write_hit);
+        fprintf(cache_logfile, "      Fetch Locks :         %16" PRId64 "", env->l3model->fetch_locks);
+        fprintf(cache_logfile, "      Flushes :             %16" PRId64 "\n", env->l3model->flush);
+        fprintf(cache_logfile, "      Fetch Lock hits :     %16" PRId64 "", env->l3model->fetch_lock_hit);
+        fprintf(cache_logfile, "      Flush hits  :         %16" PRId64 "\n", env->l3model->flush_hit);
+        fprintf(cache_logfile, "      Flush Invalidates:    %16" PRId64 "", env->l3model->flush_inv);
+        fprintf(cache_logfile, "      Flush Invalidate hits:%16" PRId64 "\n", env->l3model->flush_inv_hit);
+        fprintf(cache_logfile, "      Hit Invalidates :     %16" PRId64 "", env->l3model->invalidate);
+        fprintf(cache_logfile, "      Hit Invalidate hits : %16" PRId64 "\n", env->l3model->inv_hit);
+        fprintf(cache_logfile, "      Dirty read victim:    %16" PRId64 "", env->l3model->replace_dirty_was_read);
+        fprintf(cache_logfile, "      Dirty not read victim:%16" PRId64 "\n", env->l3model->replace_dirty_never_read);
+        fprintf(cache_logfile, "      Clean read victim:    %16" PRId64 "", env->l3model->replace_clean_was_read);
+        fprintf(cache_logfile, "      Clean not read victim:%16" PRId64 "\n\n", env->l3model->replace_clean_never_read);
+        fprintf(cache_logfile, "      Miss rate :           %16.3lf\n\n", mips_cache_miss_rate(env->l3model));
+        fprintf(cache_logfile, "--------------------------------------------"
+                               "--------------------------------------------\n");
+    }
+
+    if (env->subsystem) {
+        fprintf(cache_logfile, "Level : %s\n", env->subsystem->name);
+        fprintf(cache_logfile, "      Data reads :          %16" PRId64 "\n", env->subsystem->read_hit);
+        fprintf(cache_logfile, "      Inst. reads :         %16" PRId64 "\n", env->subsystem->ins_read_hit);
+        fprintf(cache_logfile, "      Total reads :         %16" PRId64 "\n\n", env->subsystem->reads);
+        fprintf(cache_logfile, "      Data writes :         %16" PRId64 "\n\n", env->subsystem->writes);
+        fprintf(cache_logfile, "============================================"
+                               "============================================\n");
+        fprintf(cache_logfile, "TLB Statistics\n");
+        fprintf(cache_logfile, "============================================"
+                               "============================================\n");
+        fprintf(cache_logfile, "      TLB accesses :        %16" PRId64 "\n", env->tlb->tlb_accesses);
+        fprintf(cache_logfile, "      TLB hits :            %16" PRId64 "\n", env->tlb->tlb_hit);
+        fprintf(cache_logfile, "      TLB misses :          %16" PRId64 "\n", env->tlb->tlb_miss);
+        fprintf(cache_logfile, "      TLB dirty :           %16" PRId64 "\n", env->tlb->tlb_dirty);
+        fprintf(cache_logfile, "      TLB invalid :         %16" PRId64 "\n", env->tlb->tlb_invalid);
+        fprintf(cache_logfile, "      TLB bad address :     %16" PRId64 "\n\n", env->tlb->tlb_bad_address);
+        fprintf(cache_logfile, "============================================"
+                               "============================================\n");
+
+    }
+}
+
+// Should only be inserted when cache model is enabled
+//
+void helper_mips_dc_access(CPUMIPSState *env, uint32_t type, uint32_t size, target_ulong addr) {
+    target_ulong va;
+    target_ulong pa;
+    uint32_t asid;
+    int gpa_ok = 0;
+
+    CACHE_MODEL_ENABLED();
+
+    // Translated block program counter
+    va = addr;
+
+    pa = r4k_get_phys_addr(env, va,type,&gpa_ok);
+    asid = MCASID;
+
+    // Cache block ignores uncached segments
+    //  - assumes we never get a pa of 0x0
+    //
+    if (env->dmodel && gpa_ok) mips_cache_access(env, env->dmodel,asid,va,pa,type,4,1,0);
+}
+
+static inline void mips_cache_reset_stats(CPUMIPSState *env)
+{
+    if (env->imodel) {
+        env->imodel->reads = 0;
+        env->imodel->writes = 0;
+        env->imodel->prefetch = 0;
+        env->imodel->read_hit = 0;
+        env->imodel->ins_read_hit = 0;
+        env->imodel->read_miss = 0;
+        env->imodel->ins_read_miss = 0;
+        env->imodel->write_hit = 0;
+        env->imodel->write_miss = 0;
+        env->imodel->prefetch_hit = 0;
+        env->imodel->read_allocate = 0;
+        env->imodel->write_allocate = 0;
+        env->imodel->prefetch_allocate = 0;
+        env->imodel->prefetch_for_write = 0;
+        env->imodel->prefetch_for_write_hit = 0;
+        env->imodel->prefetch_for_write_miss = 0;
+        env->imodel->prefetch_for_write_allocate = 0;
+        env->imodel->fetch_locks = 0;
+        env->imodel->fetch_lock_hit = 0;
+        env->imodel->fetch_lock_allocate = 0;
+        env->imodel->read_passthrough = 0;
+        env->imodel->write_passthrough = 0;
+        env->imodel->replace_clean_was_read = 0;
+        env->imodel->replace_clean_never_read = 0;
+        env->imodel->replace_dirty_was_read = 0;
+        env->imodel->replace_dirty_never_read = 0;
+        env->imodel->flush = 0;
+        env->imodel->invalidate = 0;
+        env->imodel->flush_inv = 0;
+        env->imodel->flush_hit = 0;
+        env->imodel->inv_hit = 0;
+        env->imodel->flush_inv_hit = 0;
+    }
+
+    if (env->dmodel) {
+        env->dmodel->reads = 0;
+        env->dmodel->writes = 0;
+        env->dmodel->prefetch = 0;
+        env->dmodel->read_hit = 0;
+        env->dmodel->ins_read_hit = 0;
+        env->dmodel->read_miss = 0;
+        env->dmodel->ins_read_miss = 0;
+        env->dmodel->write_hit = 0;
+        env->dmodel->write_miss = 0;
+        env->dmodel->prefetch_hit = 0;
+        env->dmodel->read_allocate = 0;
+        env->dmodel->write_allocate = 0;
+        env->dmodel->prefetch_allocate = 0;
+        env->dmodel->prefetch_for_write = 0;
+        env->dmodel->prefetch_for_write_hit = 0;
+        env->dmodel->prefetch_for_write_miss = 0;
+        env->dmodel->prefetch_for_write_allocate = 0;
+        env->dmodel->fetch_locks = 0;
+        env->dmodel->fetch_lock_hit = 0;
+        env->dmodel->fetch_lock_allocate = 0;
+        env->dmodel->read_passthrough = 0;
+        env->dmodel->write_passthrough = 0;
+        env->dmodel->replace_clean_was_read = 0;
+        env->dmodel->replace_clean_never_read = 0;
+        env->dmodel->replace_dirty_was_read = 0;
+        env->dmodel->replace_dirty_never_read = 0;
+        env->dmodel->flush = 0;
+        env->dmodel->invalidate = 0;
+        env->dmodel->flush_inv = 0;
+        env->dmodel->flush_hit = 0;
+        env->dmodel->inv_hit = 0;
+        env->dmodel->flush_inv_hit = 0;
+    }
+
+    if (env->l2model) {
+        env->l2model->reads = 0;
+        env->l2model->writes = 0;
+        env->l2model->prefetch = 0;
+        env->l2model->read_hit = 0;
+        env->l2model->ins_read_hit = 0;
+        env->l2model->read_miss = 0;
+        env->l2model->ins_read_miss = 0;
+        env->l2model->write_hit = 0;
+        env->l2model->write_miss = 0;
+        env->l2model->prefetch_hit = 0;
+        env->l2model->read_allocate = 0;
+        env->l2model->write_allocate = 0;
+        env->l2model->prefetch_allocate = 0;
+        env->l2model->prefetch_for_write = 0;
+        env->l2model->prefetch_for_write_hit = 0;
+        env->l2model->prefetch_for_write_miss = 0;
+        env->l2model->prefetch_for_write_allocate = 0;
+        env->l2model->fetch_locks = 0;
+        env->l2model->fetch_lock_hit = 0;
+        env->l2model->fetch_lock_allocate = 0;
+        env->l2model->read_passthrough = 0;
+        env->l2model->write_passthrough = 0;
+        env->l2model->replace_clean_was_read = 0;
+        env->l2model->replace_clean_never_read = 0;
+        env->l2model->replace_dirty_was_read = 0;
+        env->l2model->replace_dirty_never_read = 0;
+        env->l2model->flush = 0;
+        env->l2model->invalidate = 0;
+        env->l2model->flush_inv = 0;
+        env->l2model->flush_hit = 0;
+        env->l2model->inv_hit = 0;
+        env->l2model->flush_inv_hit = 0;
+    }
+
+    if (env->l3model) {
+        env->l3model->reads = 0;
+        env->l3model->writes = 0;
+        env->l3model->prefetch = 0;
+        env->l3model->read_hit = 0;
+        env->l3model->ins_read_hit = 0;
+        env->l3model->read_miss = 0;
+        env->l3model->ins_read_miss = 0;
+        env->l3model->write_hit = 0;
+        env->l3model->write_miss = 0;
+        env->l3model->prefetch_hit = 0;
+        env->l3model->read_allocate = 0;
+        env->l3model->write_allocate = 0;
+        env->l3model->prefetch_allocate = 0;
+        env->l3model->prefetch_for_write = 0;
+        env->l3model->prefetch_for_write_hit = 0;
+        env->l3model->prefetch_for_write_miss = 0;
+        env->l3model->prefetch_for_write_allocate = 0;
+        env->l3model->fetch_locks = 0;
+        env->l3model->fetch_lock_hit = 0;
+        env->l3model->fetch_lock_allocate = 0;
+        env->l3model->read_passthrough = 0;
+        env->l3model->write_passthrough = 0;
+        env->l3model->replace_clean_was_read = 0;
+        env->l3model->replace_clean_never_read = 0;
+        env->l3model->replace_dirty_was_read = 0;
+        env->l3model->replace_dirty_never_read = 0;
+        env->l3model->flush = 0;
+        env->l3model->invalidate = 0;
+        env->l3model->flush_inv = 0;
+        env->l3model->flush_hit = 0;
+        env->l3model->inv_hit = 0;
+        env->l3model->flush_inv_hit = 0;
+    }
+
+    if (env->subsystem) {
+        env->subsystem->reads = 0;
+        env->subsystem->writes = 0;
+        env->subsystem->prefetch = 0;
+        env->subsystem->read_hit = 0;
+        env->subsystem->ins_read_hit = 0;
+        env->subsystem->read_miss = 0;
+        env->subsystem->ins_read_miss = 0;
+        env->subsystem->write_hit = 0;
+        env->subsystem->write_miss = 0;
+        env->subsystem->prefetch_hit = 0;
+        env->subsystem->read_allocate = 0;
+        env->subsystem->write_allocate = 0;
+        env->subsystem->prefetch_allocate = 0;
+        env->subsystem->prefetch_for_write = 0;
+        env->subsystem->prefetch_for_write_hit = 0;
+        env->subsystem->prefetch_for_write_miss = 0;
+        env->subsystem->prefetch_for_write_allocate = 0;
+        env->subsystem->fetch_locks = 0;
+        env->subsystem->fetch_lock_hit = 0;
+        env->subsystem->fetch_lock_allocate = 0;
+        env->subsystem->read_passthrough = 0;
+        env->subsystem->write_passthrough = 0;
+        env->subsystem->replace_clean_was_read = 0;
+        env->subsystem->replace_clean_never_read = 0;
+        env->subsystem->replace_dirty_was_read = 0;
+        env->subsystem->replace_dirty_never_read = 0;
+        env->subsystem->flush = 0;
+        env->subsystem->invalidate = 0;
+        env->subsystem->flush_inv = 0;
+        env->subsystem->flush_hit = 0;
+        env->subsystem->inv_hit = 0;
+        env->subsystem->flush_inv_hit = 0;
+    }
+
+    if (env->tlb) {
+        cpu_mips_tlb_flush(env, 1);
+        env->tlb->tlb_accesses = 0;
+        env->tlb->tlb_hit = 0;
+        env->tlb->tlb_miss = 0;
+        env->tlb->tlb_dirty = 0;
+        env->tlb->tlb_invalid = 0;
+        env->tlb->tlb_bad_address = 0;
+    }
+}
+
+void helper_cache_log_toggle_on(CPUMIPSState *env)
+{
+    if (!enable_mips_cache_model && !enable_mips_icount_stats) return;
+
+    if (cache_log_on == 0) {
+        cache_logfile_init();
+
+        if (l1imodel.enable) mips_cache_report_logfile(cache_logfile, env->imodel);
+        if (l1dmodel.enable) mips_cache_report_logfile(cache_logfile, env->dmodel);
+        if (l2model.enable) mips_cache_report_logfile(cache_logfile, env->l2model);
+        if (l3model.enable) mips_cache_report_logfile(cache_logfile, env->l3model);
+
+        mips_cache_reset_stats(env);
+        reset_instruction_counters(env);
+
+        fprintf(stderr, "\nCACHE SIMULATION ENABLED\n");
+        cache_log_on = 1;
+    }
+}
+
+void helper_cache_log_toggle_off(CPUMIPSState *env)
+{
+    if (!enable_mips_cache_model && !enable_mips_icount_stats) return;
+
+    if (cache_log_on == 1) {
+        cache_log_on = 0;
+        fprintf(stderr, "\nCACHE SIMULATION DISABLED\n");
+
+        if (enable_mips_cache_model) {
+            //printf("%d ADRESA22 \n", env->imodel);
+            mips_cache_results_to_logfile(env);
+            fflush(cache_logfile);
+            fclose(cache_logfile);
+        }
+
+        if (enable_mips_icount_stats) {
+            dump_instruction_stats(env);
+            fflush(icount_logfile);
+            fclose(icount_logfile);
+        }
+    }
+}
+
+target_ulong r4k_get_phys_addr (CPUMIPSState *env, target_ulong va, int rw, int *success)
+{
+    enum {
+        TLBRET_DIRTY = -4,
+        TLBRET_INVALID = -3,
+        TLBRET_NOMATCH = -2,
+        TLBRET_BADADDR = -1,
+        TLBRET_MATCH = 0
+    };
+
+    hwaddr physical;
+    int prot = 0;
+    int ret;
+
+    ret = get_physical_address(env, &physical, &prot, va, rw, 0);
+
+    *success = 0;
+    env->tlb->tlb_accesses++;
+    switch (ret) {
+        case TLBRET_MATCH:
+            *success = 1;
+            env->tlb->tlb_hit++;
+            break;
+        case TLBRET_NOMATCH:
+            env->tlb->tlb_miss++;
+            break;
+        case TLBRET_DIRTY:
+            env->tlb->tlb_dirty++;
+            break;
+        case TLBRET_INVALID:
+            env->tlb->tlb_invalid++;
+            break;
+        case TLBRET_BADADDR:
+            env->tlb->tlb_bad_address++;
+            break;
+
+        default :
+            fprintf(stderr, "TLB get_physical_address unknown ret value\n");
+            break;
+    }
+
+    return physical;
+}
+
+
+// Should only be called when doing icache accesses per instruction
+//
+void do_icache_per_instruction(CPUMIPSState *env, target_ulong addr) {
+    int gpa_ok = 0;
+    target_ulong va;
+    target_ulong pa;
+    uint32_t asid;
+
+    // Translated block program counter
+    va = addr;
+    asid = MCASID;
+
+    if (env->imodel) {
+        if (env->IR != (va & 0XFFFFFFF0)) {
+            env->IR = (va & 0XFFFFFFF0);
+        } else {
+            // Already fetched into Instruction Register (IR)
+            return;
+        }
+
+       // Cache block ignores uncached segments
+       pa = -1;
+       pa = r4k_get_phys_addr(env, va, MIPS_CACHE_READ, &gpa_ok);
+       if (gpa_ok) mips_cache_access(env, env->imodel,asid,va,pa,MIPS_CACHE_READ,4,1,1);
+    }
+}
+
+void helper_icache_per_instruction(CPUMIPSState *env, target_ulong pc)
+{
+    CACHE_MODEL_ENABLED();
+    do_icache_per_instruction(env, pc);
+}
+
+static int mips_cache_hit(mips_cache_t *c, uint32_t asid, target_ulong va, target_ulong pa, uint32_t *set_idx)
+{
+    uint32_t way;
+    uint32_t way_hit;
+    uint32_t set_index;
+    uint32_t set_idx_w;
+    uint32_t waysize;
+    target_ulong tag_value;
+    target_ulong pa_line_addr;
+    target_ulong va_line_addr;
+    uint32_t tag_asid;
+    target_ulong *ctags;
+
+    va_line_addr = va;
+    pa_line_addr = pa;
+    set_index = 0;
+    tag_value = 0;
+    ctags = 0;
+    tag_asid = 0;
+    waysize = c->sets * c->linelength;
+
+    // Virtually indexed, physically tagged
+    if (c->type & MIPS_CACHE_TYPE_VIPT) {
+        set_index = (va % waysize) / c->linelength;
+        tag_value = pa_line_addr & ~(c->linelength-1);
+        tag_asid = 0;
+        ctags = c->ptags;
+    }
+
+    // Virtually indexed, virtually tagged
+    else if (c->type & MIPS_CACHE_TYPE_VIVT) {
+        set_index = (va % waysize) / c->linelength;
+        tag_value  = va_line_addr & ~(c->linelength-1);
+        tag_asid = asid;
+        ctags = c->vtags;
+    }
+
+    // Physically indexed, physically tagged
+    else if (c->type & MIPS_CACHE_TYPE_PIPT) {
+        set_index = (pa % waysize) / c->linelength;
+        tag_value = pa_line_addr & ~(c->linelength-1);
+        tag_asid = 0;
+        ctags = c->ptags;
+    }
+
+    // Search ways for tag
+    way_hit = -1;
+    set_idx_w = set_index * c->ways;
+
+    if (set_idx != NULL)
+        *set_idx = set_idx_w;
+
+    for (way=0; way<c->ways; way++) {
+        // Tag value matches
+        // and asid matches (unless disabled by global flag)
+        // and entry is valid
+        //
+        // Note that MIPS_CACHE_TYPE_USE_ASID parameter causes global
+        // bit to be cleared on a miss
+        //
+        if ((ctags[set_idx_w+way] == tag_value) &&
+            ((c->flags[set_idx_w+way] & MIPS_CACHE_FLAG_GLOBAL) || (c->vasid[set_idx_w+way] == tag_asid)) &&
+            (c->flags[set_idx_w+way] & MIPS_CACHE_FLAG_VALID)) {
+            way_hit = way;
+            break;
+        }
+    }
+
+    if (way_hit != -1)
+        return way_hit;
+    else
+        return -1;
+}
+
+static inline uint32_t generate_mask(uint32_t value)
+{
+    uint32_t mask, count;
+
+    mask = 0;
+    count = 0;
+    value = value - 1;
+    while (value > 0) {
+        mask = mask | (1 << (count++));
+        value = value >> 1;
+    }
+
+    return mask;
+}
+
+static inline int mips_cache_index(mips_cache_t *c, target_ulong va)
+{
+    uint32_t way_idx, set_idx;
+
+    way_idx = ((va >> ((int)log2(c->sets) +
+                       (int)log2(c->linelength))) &
+                       (generate_mask(c->ways)));
+
+    set_idx = (va >> ((int)log2(c->linelength)) &
+                      (generate_mask(c->sets)));
+    return (way_idx + set_idx);
+}
+
+static inline void mips_cache_stats(mips_cache_t *c, int cmd, uint32_t miss, uint32_t allocate,
+                                    uint32_t passthrough, uint32_t access_type, uint32_t seq)
+{
+    // Stats, if enabled
+    switch(cmd) {
+        case MIPS_CACHE_FETCH_AND_LOCK:
+            c->fetch_locks+=seq;
+            c->reads+=seq;
+            if (!miss) {
+                c->fetch_lock_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+            } else {
+                c->read_miss += seq;
+                if (access_type == 1) c->ins_read_miss += seq;
+            }
+            if (miss && allocate)   c->fetch_lock_hit += seq-1;   // miss, allocate
+            if (allocate)           c->fetch_lock_allocate += 1;
+            break;
+
+        case MIPS_CACHE_PREFETCH:
+            c->prefetch+=seq;
+            c->reads+=seq;
+            if (!miss) {
+                c->prefetch_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+            } else {
+                c->read_miss += seq;
+                if (access_type == 1) c->ins_read_miss += seq;
+            }
+            if (miss && allocate)   c->prefetch_hit += seq-1;   // miss, allocate
+            if (allocate)           c->prefetch_allocate += 1;
+            break;
+
+        case MIPS_CACHE_PREFETCH_RETAINED:
+            c->prefetch+=seq;
+            c->reads+=seq;
+            if (!miss) {
+                c->prefetch_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+            } else {
+                c->read_miss += seq;
+                if (access_type == 1) c->ins_read_miss += seq;
+            }
+            if (miss && allocate)   c->prefetch_hit += seq-1;   // miss, allocate
+            if (allocate)           c->prefetch_allocate += 1;
+            break;
+
+        case MIPS_CACHE_PREFETCH_FOR_WRITE:
+            c->prefetch_for_write+=seq;
+            if (!miss) {
+                c->prefetch_for_write_hit += seq;     // hit
+            } else {
+                c->prefetch_for_write_miss += seq;
+            }
+            if (miss && allocate)   c->prefetch_for_write_hit += seq-1;   // miss, allocate
+            if (allocate)           c->prefetch_for_write_allocate += 1;
+            break;
+
+        case MIPS_CACHE_READ:
+            c->reads+=seq;
+            if (!miss) {
+                c->read_hit += seq;         // hit
+                if (access_type == 1)
+                    c->ins_read_hit += seq;
+            } else {
+                c->read_miss += seq;        // miss
+                if (access_type == 1) c->ins_read_miss += seq;
+            }
+            if (miss && allocate) {
+                                    c->read_hit += seq-1;       // miss, allocate
+            }
+            if (allocate)           c->read_allocate += 1;
+            if (passthrough)        c->read_passthrough += seq;
+            break;
+
+        case MIPS_CACHE_WRITE:
+            c->writes+=seq;
+            if (!miss) {
+                c->write_hit += seq;        // hit
+            } else {
+                c->write_miss += seq;       // miss
+            }
+            if (miss && allocate)   c->write_hit += seq - 1;    // miss, allocate
+            if (allocate)           c->write_allocate += 1;
+            if (passthrough)        c->write_passthrough += seq;
+            break;
+
+        case MIPS_CACHE_FLUSH :
+            c->flush+=1;
+            if (!miss) c->flush_hit+=1;
+            break;
+
+        case MIPS_CACHE_INVALIDATE:
+            c->invalidate+=1;
+            if (!miss) c->inv_hit+=1;
+            break;
+
+        case MIPS_CACHE_FLUSH_INV:
+            c->flush_inv+=1;
+            if (!miss) c->flush_inv_hit+=1;
+            break;
+
+        default: break;
+    }
+}
+
+/* Access from the cache
+ *   - does not check for accesses which cross line boundaries
+ *
+ * To implement coherency (MSI):
+ * -----------------------------
+ *
+ *  - read-invalid   - send flush request, read      -> shared
+ *  - read-shared    - no action                     ->
+ *  - read-modified  - no action                     ->
+ *
+ *  - write-invalid  - send invalidate request, read -> modified
+ *  - write-shared   - send invalidate request, read -> modified
+ *  - write-modified - no action                     ->
+ *
+ *  - invalidate-invalid - no action                 ->
+ *  - invalidate-shared  - invalidate                -> invalid
+ *  - invalidate-modified - writeback, invalidate    -> invalid
+ *
+ *  - flush-invalid  - no action                     ->
+ *  - flush-shared   - no action                     ->
+ *  - flush-modified - writeback                     -> shared
+ *
+ *  Sequential transactions must be within the same cache line to be
+ *  counted properly - this function does not check.
+ *
+ */
+void mips_cache_access( CPUMIPSState *env,
+                        mips_cache_t *c,        // Cache structure
+                        uint32_t asid,
+                        target_ulong va,        // Virtual address
+                        target_ulong pa,        // Physical address
+                        uint32_t cmd,           // Command
+                        uint32_t size,          // Size of transaction (unused at present)
+                        uint32_t seq,           // Number of sequential transactions (within same line)
+                        uint32_t access_type) { // Type of cache access, instruction (1)/data (0)
+
+    uint32_t way;
+    uint32_t way_hit;
+    uint32_t set_index;
+    uint32_t set_idx_w;
+    uint32_t index;
+    uint32_t allocate;
+    uint32_t uncached;
+    uint32_t passthrough;
+    uint32_t miss;
+    uint32_t victim_way;
+    uint64_t minval,maxval;
+    uint32_t waysize;
+    uint32_t segment;
+    uint32_t i,n,j;
+    target_ulong tag_value;
+    target_ulong pa_line_addr;
+    target_ulong va_line_addr;
+    target_ulong *ctags;
+    uint32_t nmru[8];
+    uint32_t tag_asid;
+
+    if (strcmp(c->name, "subsystem") == 0) {
+        switch(cmd) {
+            case MIPS_CACHE_READ:
+                c->reads += seq;
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+                break;
+
+            case MIPS_CACHE_WRITE:
+                c->writes += seq;
+                break;
+
+            case MIPS_CACHE_PREFETCH:
+                c->prefetch+=seq;
+                c->reads+=seq;
+                c->prefetch_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+
+                break;
+
+            case MIPS_CACHE_PREFETCH_RETAINED:
+                c->prefetch+=seq;
+                c->reads+=seq;
+                c->prefetch_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+
+                break;
+
+            case MIPS_CACHE_FETCH_AND_LOCK:
+                c->fetch_locks+=seq;
+                c->reads+=seq;
+                c->fetch_lock_hit += seq;     // hit
+                if (access_type == 1) {
+                    c->ins_read_hit += seq;
+                } else {
+                    c->read_hit += seq;
+                }
+
+                break;
+
+            default : break;
+        }
+        return;
+    }
+
+    tag_asid = 0;
+
+    // Segment - decode top three bits of address
+    segment = (va >> 29) & 7;                   // top three bits
+    segment = (1<<segment);                     // make into one-hot
+    uncached = 0;
+
+    // Passthrough accesses to kseg0,1,2
+    if (c->type & MIPS_CACHE_TYPE_PASS_K) {
+        if (segment>(MIPS_CACHE_MEM_KUSEG>>24)) uncached = 1;
+        }
+
+    // Passthrough accesses to kseg1 only
+    if (c->type & MIPS_CACHE_TYPE_PASS_K1) {
+        if (segment==(MIPS_CACHE_MEM_KSEG1>>24)) uncached = 1;
+    }
+
+    segment = segment & ((c->type>>24)&0xff);         // compare with mask
+
+    if (uncached) {
+        return;
+    }
+
+    // Line address
+    va_line_addr = va;
+    pa_line_addr = pa;
+    allocate = 0;
+    victim_way = 0;
+    passthrough = 0;
+
+    // Compute set index, tag address
+    set_index = 0;
+    tag_value = 0;
+    waysize = c->sets * c->linelength;
+    ctags = 0;
+
+    // Virtually indexed, physically tagged
+    if (c->type & MIPS_CACHE_TYPE_VIPT) {
+        set_index = (va % waysize) / c->linelength;
+        tag_value = pa_line_addr & ~(c->linelength-1);
+        tag_asid = 0;
+        ctags = c->ptags;
+    }
+
+    // Virtually indexed, virtually tagged
+    else if (c->type & MIPS_CACHE_TYPE_VIVT) {
+        set_index = (va % waysize) / c->linelength;
+        tag_value  = va_line_addr & ~(c->linelength-1);
+        tag_asid = asid;
+        ctags = c->vtags;
+    }
+
+    // Physically indexed, physically tagged
+    else if (c->type & MIPS_CACHE_TYPE_PIPT) {
+        set_index = (pa % waysize) / c->linelength;
+        tag_value = pa_line_addr & ~(c->linelength-1);
+        tag_asid = 0;
+        ctags = c->ptags;
+    }
+
+    // Search ways for tag
+    miss = 1;
+    way_hit = -1;
+    set_idx_w = set_index * c->ways;
+    index = mips_cache_index(c, va);
+    if (c->flags) {
+        if ((cmd == MIPS_CACHE_INDEX_INVALIDATE) &&
+            (c->flags[index] & MIPS_CACHE_FLAG_VALID)) {
+#ifdef CACHE_DEBUG
+            fprintf(cache_logfile,"%s : Invalidate line - index %d, va = 0x%08x, pa = 0x%08x\n",
+                    c->name,index,c->vtags[index],c->ptags[index]);
+#endif
+            c->flags[index] = 0;
+
+            return;
+        } else if (cmd == MIPS_CACHE_INDEX_WB_INVALIDATE) {
+            if ((c->flags[index] & MIPS_CACHE_FLAG_DIRTY) &&
+                (c->flags[index] & MIPS_CACHE_FLAG_VALID)) {
+
+#ifdef CACHE_DEBUG
+                fprintf(cache_logfile,"%s : Write back invalidate line - index %d, va = 0x%08x, pa = 0x%08x\n",
+                        c->name,index,c->vtags[index],c->ptags[index]);
+#endif
+                // Write it to the next level
+                if (c->next_level) {
+                    // Fix write counts
+                    c->next_level->writes -= seq;
+                    if (mips_cache_hit(c, asid, va, pa, NULL) != -1) {
+                        c->next_level->write_hit -= seq;
+                    } else {
+                        c->next_level->write_miss -= seq;
+                    }
+
+                    mips_cache_access(env, c->next_level,
+                                      c->vasid[index],
+                                      c->vtags[index],
+                                      c->ptags[index],
+                                      MIPS_CACHE_WRITE,
+                                      c->linelength,
+                                      1,
+                                      access_type);
+                }
+                // Clear dirty flag
+                c->flags[index] = 0;
+            } else if (c->flags[index] & MIPS_CACHE_FLAG_VALID) {
+
+#ifdef CACHE_DEBUG
+                fprintf(cache_logfile,"%s : Invalidate line - index %d, va = 0x%08x, pa = 0x%08x\n",
+                        c->name,index,c->vtags[index],c->ptags[index]);
+#endif
+                c->flags[index] = 0;
+            }
+            return;
+        }
+    }
+
+    if (!uncached) {
+        for (way=0; way<c->ways; way++) {
+            // Tag value matches
+            // and asid matches (unless disabled by global flag)
+            // and entry is valid
+            //
+            // Note that MIPS_CACHE_TYPE_USE_ASID parameter causes global
+            // bit to be cleared on a miss
+            //
+            if ((ctags[set_idx_w+way] == tag_value) &&
+                ((c->flags[set_idx_w+way] & MIPS_CACHE_FLAG_GLOBAL) || (c->vasid[set_idx_w+way] == tag_asid)) &&
+                (c->flags[set_idx_w+way] & MIPS_CACHE_FLAG_VALID)) {
+
+                way_hit = way;
+                miss = 0;
+                break;
+                }
+            }
+        }
+
+    if (way_hit == -1) {
+            // Miss
+            //
+            // Decide whether to allocate a line
+            // Default to pass through reads and writes if not allocated
+            if ((cmd==MIPS_CACHE_READ)||(cmd==MIPS_CACHE_WRITE))
+                passthrough = 1;
+
+            // Allocate on read? write? prefetch?
+            if (c->type && !uncached) {
+                switch(cmd) {
+                    case MIPS_CACHE_READ:  allocate = c->type & MIPS_CACHE_TYPE_RDAL; break;
+                    case MIPS_CACHE_WRITE: allocate = c->type & MIPS_CACHE_TYPE_WRAL; break;
+                    case MIPS_CACHE_PREFETCH: allocate = c->type & MIPS_CACHE_TYPE_RDAL; break;
+                    case MIPS_CACHE_PREFETCH_RETAINED: allocate = c->type & MIPS_CACHE_TYPE_RDAL; break;
+                    case MIPS_CACHE_PREFETCH_FOR_WRITE: allocate = c->type & MIPS_CACHE_TYPE_RDAL; break;
+                    case MIPS_CACHE_FETCH_AND_LOCK: allocate = c->type & MIPS_CACHE_TYPE_RDAL; break;
+                    default: break;
+                    }
+                }
+
+            // Pick a victim
+            if (allocate) {
+                // Don't pass through the access
+                passthrough = 0;
+
+                // Line addresses
+                va_line_addr = va & ~(c->linelength-1);
+                pa_line_addr = pa & ~(c->linelength-1);
+
+                // 'Random' replacement
+                if (c->type & MIPS_CACHE_TYPE_RANDOM)
+                    victim_way = rand() % c->ways;
+
+                // 'Round robin' per-set replacement
+                else if (c->type & MIPS_CACHE_TYPE_ROBIN) {
+                    victim_way = c->times[set_idx_w];
+                    c->times[set_idx_w] = (c->times[set_idx_w]+1) % c->ways;
+                }
+
+                // 'LRU' per-set replacement
+                else if (c->type & MIPS_CACHE_TYPE_LRU) {
+                    minval=c->times[set_idx_w+0];
+                    victim_way=0;
+                    for (way=0; way<c->ways; way++) {
+                        if (!(c->flags[set_idx_w+way] & MIPS_CACHE_FLAG_VALID)) {
+                            victim_way = way;
+                            break;
+                        }
+                    }
+                    if (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_VALID) {
+                        for (way=1; way<c->ways; way++) {
+                            if (c->times[set_idx_w+way] < minval) {
+                                victim_way = way;
+                                minval = c->times[set_idx_w+way];
+                            }
+                        }
+                    }
+                }
+
+                // Not-most-recently-used-4 per-set replacement
+                // - for modelling exclusion of uTLB contents from random replacement
+                // - get a random way. if it's one of the most-recently used 4, get another.
+                else if ((c->type & MIPS_CACHE_TYPE_NMRU4) ||
+                         (c->type & MIPS_CACHE_TYPE_NMRU8)) {
+
+                    n = (c->type & MIPS_CACHE_TYPE_NMRU4) ? 4 : 8;
+
+                    // Nasty way to build most recent 4/8 indexes
+                    // - a true sort would probably be better
+                    //
+                    minval = 0;
+                    way=0;
+                    for (i=0;i<n;i++) {
+                        maxval = 0;
+                        for (j=0;j<c->ways;j++) {
+                            // find biggest value which isn't bigger than the threshold (minval)
+                            if ((c->times[set_idx_w+j] > maxval) &&
+                                ((i==0) ||
+                                 (c->times[set_idx_w+j] < minval))) {
+                                maxval = c->times[set_idx_w+j];
+                                way = j;
+                            }
+                        }
+                        minval = maxval;
+                        nmru[i] = way;
+                    }
+
+                    // Get a random entry not part of the most recently used part
+                    victim_way = -1;
+                    while (victim_way == -1) {
+                        victim_way = rand() % c->ways;
+                        for (i=0; i<n; i++) {
+                            if (nmru[i] == victim_way) victim_way = -1;
+                        }
+                    }
+                }
+
+                // Stats for valid replacement victims
+                if (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_VALID) {
+                    if (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_DIRTY) {
+                        // Dirty
+                        if (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_READ)
+                                c->replace_dirty_was_read += 1;
+                        else    c->replace_dirty_never_read += 1;
+                        }
+                    else {
+                        // Clean
+                        if (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_READ) {
+                                c->replace_clean_was_read += 1;
+                            }
+                        else    c->replace_clean_never_read += 1;
+                        }
+                    }
+
+                if (((cmd == MIPS_CACHE_FETCH_AND_LOCK)     ||
+                    (cmd == MIPS_CACHE_PREFETCH)            ||
+                    (cmd == MIPS_CACHE_PREFETCH_RETAINED)   ||
+                    (cmd == MIPS_CACHE_PREFETCH_FOR_WRITE)  ||
+                    (cmd == MIPS_CACHE_READ)                ||
+                    (cmd == MIPS_CACHE_WRITE))
+                    &&
+                    ((c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_LOCK) &&
+                     (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_VALID))) {
+
+                    switch (cmd) {
+                        case MIPS_CACHE_READ:
+                        case MIPS_CACHE_WRITE:
+                            if (c->next_level)
+                                mips_cache_access(env, c->next_level, asid, va, pa, cmd, size, seq, access_type);
+                            break;
+
+                        default : break;
+                    }
+                    if ((cmd==MIPS_CACHE_WRITE)&&(c->type & MIPS_CACHE_TYPE_WTHRU)) passthrough=1;
+                    allocate = 0;
+                    mips_cache_stats(c, cmd, miss, allocate, passthrough, access_type, seq);
+
+                    return;
+                }
+
+                // Streamed prefetches must not displace Retained prefetches
+                if ((cmd == MIPS_CACHE_PREFETCH) &&
+                    (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_RETAIN) &&
+                    (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_VALID))
+                    return;
+
+                // Write back dirty victim, if necessary
+                //  - write-through caches should never be set dirty
+                //
+                if (c->type) {
+                    if ((c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_VALID) &&
+                        (c->flags[set_idx_w+victim_way] & MIPS_CACHE_FLAG_DIRTY)) {
+#ifdef CACHE_DEBUG
+                        fprintf(cache_logfile ,"%s : Evicting line - set %d way %d, va = 0x%08x, pa = 0x%08x - flags = 0x%x\n",
+                                c->name, set_idx_w, victim_way,
+                                c->vtags[set_idx_w+victim_way],
+                                c->ptags[set_idx_w+victim_way],
+                                c->flags[set_idx_w+victim_way]);
+#endif
+                        // Write it to the next level
+                        if (c->next_level) {
+                            mips_cache_access(env, c->next_level,
+                                              c->vasid[set_idx_w+victim_way],
+                                              c->vtags[set_idx_w+victim_way],
+                                              c->ptags[set_idx_w+victim_way],
+                                              MIPS_CACHE_WRITE,
+                                              c->linelength,
+                                              1,
+                                              access_type);
+                        }
+                    }
+                }
+
+                // Tag for incoming line
+                if (c->type) {
+                    c->ptags[set_idx_w+victim_way] = pa_line_addr;
+                    c->vtags[set_idx_w+victim_way] = va_line_addr;
+                    c->vasid[set_idx_w+victim_way] = tag_asid;
+                }
+
+                // Valid bit for incoming line
+                //  - clean all other bits
+                //  - has-been-read & dirty bits set below
+                //
+                c->flags[set_idx_w+victim_way] = MIPS_CACHE_FLAG_VALID;
+
+                // If prefetch "load/store retained" operation
+                // set retain flag
+                if (cmd == MIPS_CACHE_PREFETCH_RETAINED)
+                    c->flags[set_idx_w+victim_way] |= MIPS_CACHE_FLAG_RETAIN;
+
+                // Don't check ASID unless asked to do so
+                if (!(c->type & MIPS_CACHE_TYPE_USE_ASID))
+                    c->flags[set_idx_w+victim_way] |= MIPS_CACHE_FLAG_GLOBAL;
+
+                // Access next level of heirarchy for line load
+                //
+                if (c->next_level != NULL)
+                    mips_cache_access(env, c->next_level, asid, va, pa,
+                                      cmd, c->linelength,1, access_type);
+
+                // Now we have a line, make it look like a hit for code below
+                way_hit = victim_way;
+                } // allocate
+            }
+
+    else {
+            // Hit
+            // Cache command - Flush dirty line
+            if ((cmd==MIPS_CACHE_FLUSH_INV) || (cmd==MIPS_CACHE_FLUSH)) {
+                if (c->flags[set_idx_w+way_hit] & MIPS_CACHE_FLAG_DIRTY) {
+
+#ifdef CACHE_DEBUG
+                        fprintf(cache_logfile,"%s : Flushing line - way %d, va = 0x%08x, pa = 0x%08x\n",
+                                c->name,way_hit,c->vtags[set_idx_w+way_hit],c->ptags[set_idx_w+way_hit]);
+#endif
+
+                        // Write it to the next level
+                        if (c->next_level)
+                            mips_cache_access(env, c->next_level,
+                                              c->vasid[set_idx_w+way_hit],
+                                              c->vtags[set_idx_w+way_hit],
+                                              c->ptags[set_idx_w+way_hit],
+                                              MIPS_CACHE_WRITE,
+                                              c->linelength,
+                                              1,
+                                              access_type);
+                    // Clear dirty flag
+                    c->flags[set_idx_w+way_hit] &= ~MIPS_CACHE_FLAG_DIRTY;
+                }
+            }
+
+            // Cache command - Invalidate line
+            //  - should be clean by now if flush was necessary
+            if ((cmd==MIPS_CACHE_FLUSH_INV) || (cmd==MIPS_CACHE_INVALIDATE)) {
+                c->flags[set_idx_w+way_hit] = 0;
+            }
+
+            if (cmd == MIPS_CACHE_PREFETCH_RETAINED)
+                c->flags[set_idx_w+way_hit] |= MIPS_CACHE_FLAG_RETAIN;
+    }
+
+    // pass through all writes in write-through cache
+    if ((cmd==MIPS_CACHE_WRITE) && (c->type & MIPS_CACHE_TYPE_WTHRU)) passthrough=1;
+
+    // Pass through the access
+    //  - read miss, no read allocate
+    //  - write miss, no write allocate
+    //  - write hit or miss, write-through cache
+    //
+    if (passthrough && c->next_level) {
+        mips_cache_access(env, c->next_level, asid, va, pa, cmd, size, seq, access_type);
+    }
+
+    // Set flags for line-hit, or freshly allocated line
+    //
+    if ((c->type)&&(way_hit!=-1)) {
+        if (cmd == MIPS_CACHE_FETCH_AND_LOCK)
+            c->flags[set_idx_w+way_hit] |= MIPS_CACHE_FLAG_LOCK;
+
+        // Set 'has-been-read' flag
+        if (cmd == MIPS_CACHE_READ)
+            c->flags[set_idx_w+way_hit] |= MIPS_CACHE_FLAG_READ;
+
+        // Set dirty flag, for write-back cache
+        if (((cmd == MIPS_CACHE_WRITE) || (cmd == MIPS_CACHE_PREFETCH_FOR_WRITE)) &&
+            (c->type & MIPS_CACHE_TYPE_WBACK))  {
+            c->flags[set_idx_w+way_hit] |= MIPS_CACHE_FLAG_DIRTY;
+            }
+
+        // Set LRU time - reads and writes
+        if (c->type & (MIPS_CACHE_TYPE_LRU | MIPS_CACHE_TYPE_NMRU4 | MIPS_CACHE_TYPE_NMRU8))
+            c->times[set_idx_w+way_hit] = *(c->timeptr);
+    }
+
+    // Update LRU/Random time counter
+    //  - a pointer to allow sharing of structures between differently configured caches
+    //
+   *(c->timeptr)+=seq;
+
+    mips_cache_stats(c, cmd, miss, allocate, passthrough, access_type, seq);
+}
+
+static inline void mips_cache_index_load_tag(CPUMIPSState *env, mips_cache_t *c, target_ulong va)
+{
+    target_ulong *ctags;
+    int index = mips_cache_index(c, va);
+
+    ctags = NULL;
+    // Virtually indexed, physically tagged
+    if (c->type & MIPS_CACHE_TYPE_VIPT) {
+        ctags = c->ptags;
+    }
+    // Virtually indexed, virtually tagged
+    else if (c->type & MIPS_CACHE_TYPE_VIVT) {
+        ctags = c->vtags;
+    }
+    // Physically indexed, physically tagged
+    else if (c->type & MIPS_CACHE_TYPE_PIPT) {
+        ctags = c->ptags;
+    }
+
+    if (ctags) {
+        env->CP0_TagLo = ctags[index] & 0xFFFF;
+        env->CP0_TagHi = (ctags[index] >> 16) & 0xFFFF;
+
+#ifdef CACHE_DEBUG
+        fprintf(cache_logfile, "tagLo = 0x%08x tagHi = 0x%08x entry = %d\n",
+                                env->CP0_TagLo, env->CP0_TagHi, index);
+#endif
+    }
+}
+
+static inline void mips_cache_index_store_tag(CPUMIPSState *env, mips_cache_t *c, target_ulong va)
+{
+    target_ulong *ctags;
+    int index = mips_cache_index(c, va);
+
+    ctags = NULL;
+    // Virtually indexed, physically tagged
+    if (c->type & MIPS_CACHE_TYPE_VIPT) {
+        ctags = c->ptags;
+    }
+    // Virtually indexed, virtually tagged
+    else if (c->type & MIPS_CACHE_TYPE_VIVT) {
+        ctags = c->vtags;
+    }
+    // Physically indexed, physically tagged
+    else if (c->type & MIPS_CACHE_TYPE_PIPT) {
+        ctags = c->ptags;
+    }
+
+    if (ctags) {
+        ctags[index] = (env->CP0_TagHi << 16) | env->CP0_TagLo;
+        c->flags[index] = 0;
+        c->flags[index] |= MIPS_CACHE_FLAG_VALID;
+
+#ifdef CACHE_DEBUG
+        fprintf(cache_logfile, "tagLo = 0x%08x tagHi = 0x%08x index = %d ctag = 0x%08x\n",
+                                env->CP0_TagLo, env->CP0_TagHi, index, ctags[index]);
+#endif
+    }
+}
+
+void helper_synci_op(CPUMIPSState *env, uint32_t opcode)
+{
+    uint16_t imm;
+    target_ulong va, pa;
+    int gpa_ok = 0;
+    int base;
+
+    CACHE_MODEL_ENABLED();
+
+    base = (opcode >> 21) & 0x1f;
+    imm = (int16_t)opcode;
+
+    // Address
+    va = env->active_tc.gpr[base] + imm;
+
+    if (env->dmodel) {
+        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+            if (gpa_ok) {
+                mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_FLUSH, 4, 1, 0);
+            }
+        }
+    }
+
+    if (env->imodel) {
+        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+            if (gpa_ok) {
+                mips_cache_access(env, env->imodel, MCASID, va, pa, MIPS_CACHE_INVALIDATE, 4, 1, 1);
+            }
+        }
+    }
+}
+
+void helper_cache_op(CPUMIPSState *env, uint32_t opcode)
+{
+    int cache_target;
+    int cache_op, operation;
+    target_ulong pa, va;
+    int gpa_ok = 0;
+    int base;
+    uint16_t imm;
+
+    CACHE_MODEL_ENABLED();
+
+    operation = (opcode >> 16) & 0x1F;
+    base = (opcode >> 21) & 0x1f;
+    imm = (int16_t)opcode;
+
+    // Address
+    va = env->active_tc.gpr[base] + imm;
+
+    // Bottom 2 bits indicate cache target
+    cache_target = operation & 3;
+    cache_op     = (operation >> 2) & 7;
+
+    pa =0;
+
+#ifdef CACHE_DEBUG
+        switch(cache_target) {
+            case 0 : fprintf(cache_logfile,"primary-i "); break;
+            case 1 : fprintf(cache_logfile,"primary-d "); break;
+            case 2 : fprintf(cache_logfile,"tertiary  "); break;
+            case 3 : fprintf(cache_logfile,"secondary "); break;
+            default: break;
+            }
+        switch(cache_op) {
+            case 0 : fprintf(cache_logfile,"index-wb-invalidate "); break;
+            case 1 : fprintf(cache_logfile,"index-load-tag      "); break;
+            case 2 : fprintf(cache_logfile,"index-store-tag     "); break;
+            case 3 : fprintf(cache_logfile,"impl. dependent     "); break;
+            case 4 : fprintf(cache_logfile,"hit-invalidate      "); break;
+            case 5 :
+                if (cache_target==0)
+                     fprintf(cache_logfile,"fill                ");
+                else
+                     fprintf(cache_logfile,"hit-wb-invalidate   ");
+                break;
+            case 6 : fprintf(cache_logfile,"hit-writeback       "); break;
+            case 7 : fprintf(cache_logfile,"hit-fetch-and-lock  "); break;
+            default: break;
+            }
+        fprintf(cache_logfile,"cache op 0x%08x - %x\n",va,cache_op);
+#endif
+
+    switch(cache_target) {
+        // Instruction Cache
+        case 0 :
+            switch(cache_op) {
+                // Index-invalidate
+                case 0 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_access(env, env->imodel, MCASID, va, pa, MIPS_CACHE_INDEX_INVALIDATE, 4, 1, 1);
+                        }
+                    }
+                    break;
+
+                // Index Load TAG
+                case 1 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_load_tag(env, env->imodel, va);
+                        }
+                    }
+                    break;
+
+                // Index Store TAG
+                case 2 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_store_tag(env, env->imodel, va);
+                        }
+                    }
+                    break;
+
+                // Hit-invalidate
+                case 4 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->imodel, MCASID, va, pa, MIPS_CACHE_INVALIDATE, 4, 1, 1);
+                        }
+                    }
+                    break;
+
+                // Fill
+                case 5 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok) {
+                                mips_cache_access(env, env->imodel, MCASID, va, pa, MIPS_CACHE_READ, 4, 1, 1);
+                            }
+                        }
+                    }
+                    break;
+
+                // Fetch and lock
+                case 7 :
+                    if (env->imodel) {
+                        if (env->imodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->imodel, MCASID, va, pa, MIPS_CACHE_FETCH_AND_LOCK, 4, 1, 1);
+                        }
+                    }
+                    break;
+
+                // Everything else is unimplemented
+                default:
+                    break; }
+            break;
+
+        // Data Cache
+        case 1 :
+            switch(cache_op) {
+                // Index-invalidate / Index-writeback-invalidate
+                case 0 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_INDEX_WB_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Index Load TAG
+                case 1 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_load_tag(env, env->dmodel, va);
+                        }
+                    }
+                    break;
+
+                // Index Store TAG
+                case 2 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_store_tag(env, env->dmodel, va);
+                        }
+                    }
+                    break;
+
+                // Hit-invalidate
+                case 4 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback-invalidate
+                case 5 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_FLUSH_INV, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback
+                case 6 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_FLUSH, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Fetch and Lock
+                case 7 :
+                    if (env->dmodel) {
+                        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->dmodel, MCASID, va, pa, MIPS_CACHE_FETCH_AND_LOCK, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Everything else is unimplemented
+                default:
+                    break;
+            }
+            break;
+
+        // Tertiary cache
+        case 2 :
+            switch(cache_op) {
+                // Index-invalidate / Index-writeback-invalidate
+                case 0 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_access(env, env->l3model, MCASID, va, pa, MIPS_CACHE_INDEX_WB_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Index Load TAG
+                case 1 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_load_tag(env, env->l3model, va);
+                        }
+                    }
+                    break;
+
+                // Index Store TAG
+                case 2 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_store_tag(env, env->l3model, va);
+                        }
+                    }
+                    break;
+
+                // Hit-invalidate
+                case 4 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l3model, MCASID, va, pa, MIPS_CACHE_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback-invalidate
+                case 5 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l3model, MCASID, va, pa, MIPS_CACHE_FLUSH_INV, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback
+                case 6 :
+                    if (env->l3model) {
+                        if (env->l3model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l3model, MCASID, va, pa, MIPS_CACHE_FLUSH, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                default :
+                    break;
+            }
+            break;
+
+        // Secondary cache
+        case 3 :
+            switch(cache_op) {
+                // Index-invalidate / Index-writeback-invalidate
+                case 0 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_access(env, env->l2model, MCASID, va, pa, MIPS_CACHE_INDEX_WB_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Index Load TAG
+                case 1 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_load_tag(env, env->l2model, va);
+                        }
+                    }
+                    break;
+
+                // Index Store TAG
+                case 2 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            mips_cache_index_store_tag(env, env->l2model, va);
+                        }
+                    }
+                    break;
+
+                // Hit-invalidate
+                case 4 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l2model, MCASID, va, pa, MIPS_CACHE_INVALIDATE, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback-invalidate
+                case 5 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l2model, MCASID, va, pa, MIPS_CACHE_FLUSH_INV, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                // Hit-writeback
+                case 6 :
+                    if (env->l2model) {
+                        if (env->l2model->type & MIPS_CACHE_TYPE_EN_OPS) {
+                            pa = r4k_get_phys_addr(env,va,MIPS_CACHE_READ,&gpa_ok);
+                            if (gpa_ok)
+                                mips_cache_access(env, env->l2model, MCASID, va, pa, MIPS_CACHE_FLUSH, 4, 1, 0);
+                        }
+                    }
+                    break;
+
+                default :
+                    break;
+            }
+
+        default: break;
+    }
+}
+
+void helper_prefetch_op(CPUMIPSState *env, uint32_t opcode)
+{
+    int hint;
+    target_ulong addr;
+    target_ulong pa;
+    int gpa_ok = 0;
+    int base;
+    uint16_t imm;
+
+    CACHE_MODEL_ENABLED();
+
+    base = (opcode >> 21) & 0x1f;
+    imm = (int16_t)opcode;
+
+    // Address
+    addr = env->active_tc.gpr[base] + imm;
+    hint = (opcode >> 16) & 0x1F;
+
+#ifdef CACHE_DEBUG
+        fprintf(cache_logfile,"prefetch op - addr = 0x%08x hint = %d -- ",addr,hint);
+        switch(hint) {
+            case 0  : fprintf(cache_logfile,"load "); break;
+            case 1  : fprintf(cache_logfile,"store"); break;
+            case 25 : fprintf(cache_logfile,"nudge"); break;
+            case 30 : fprintf(cache_logfile,"(p4s)"); break;
+            default : fprintf(cache_logfile,"unimp"); break;
+            }
+        fprintf(cache_logfile,"\n");
+#endif
+
+    pa = 0;
+
+    if (env->dmodel) {
+        if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+            if (hint != 30) {
+                pa = r4k_get_phys_addr(env,addr,MIPS_CACHE_READ,&gpa_ok);
+            } else {
+                pa = r4k_get_phys_addr(env,addr,MIPS_CACHE_WRITE,&gpa_ok);
+            }
+        }
+    }
+
+    // Do the cache operations - on the data cache
+    //
+    switch(hint) {
+        // Load + Store
+        case 0 :
+        case 1 :
+            if (gpa_ok && env->dmodel) {
+                if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                    mips_cache_access(env, env->dmodel, MCASID, addr, pa, MIPS_CACHE_READ, 4, 1, 0);
+                }
+            }
+            break;
+
+        // Load + Store streamed
+        case 4 :
+        case 5 :
+            if (gpa_ok && env->dmodel) {
+                if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                    mips_cache_access(env, env->dmodel, MCASID, addr, pa, MIPS_CACHE_PREFETCH, 4, 1, 0);
+                }
+            }
+            break;
+
+        // Load + Store retained
+        case 6 :
+        case 7 :
+            if (gpa_ok && env->dmodel) {
+                if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                    mips_cache_access(env, env->dmodel, MCASID, addr, pa, MIPS_CACHE_PREFETCH_RETAINED, 4, 1, 0);
+                }
+            }
+            break;
+
+        // Nudge (writeback-invalidate)
+        case 25 :
+            if (gpa_ok && env->dmodel) {
+                if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                    mips_cache_access(env, env->dmodel, MCASID, addr, pa, MIPS_CACHE_FLUSH_INV, 4, 1, 0);
+                }
+            }
+            break;
+
+        case 30 :
+            if (gpa_ok && env->dmodel) {
+                if (env->dmodel->type & MIPS_CACHE_TYPE_EN_OPS) {
+                    mips_cache_access(env, env->dmodel, MCASID, addr, pa, MIPS_CACHE_PREFETCH_FOR_WRITE, 4, 1, 0);
+                }
+            }
+            break;
+
+        // Anything else
+        default:
+            break;
+        }
+}
+
+void helper_instruction_count(CPUMIPSState *env, uint32_t opcode)
+{
+    CACHE_MODEL_ENABLED();
+    do_instruction_count(env, opcode);
+}
+
+char const *decode_icount_index(int index)
+{
+    switch(index) {
+        case 0 : return "SLL";
+        case 1 : return "SRA";
+        case 2 : return "SRL";
+        case 3 : return "MOVN";
+        case 4 : return "MOVZ";
+        case 5 : return "ADD";
+        case 6 : return "ADDU";
+        case 7 : return "SUB";
+        case 8 : return "SUBU";
+        case 9 : return "SLLV";
+        case 10 : return "SRAV";
+        case 11 : return "SRLV";
+        case 12 : return "SLT";
+        case 13 : return "SLTU";
+        case 14 : return "AND";
+        case 15 : return "OR";
+        case 16 : return "NOR";
+        case 17 : return "XOR";
+        case 18 : return "MULT";
+        case 19 : return "MULTU";
+        case 20 : return "DIV";
+        case 21 : return "DIVU";
+        case 22 : return "JR";
+        case 23 : return "JALR";
+        case 24 : return "JALRC";
+        case 25 : return "JALRS";
+        case 26 : return "TGE";
+        case 27 : return "TGEU";
+        case 28 : return "TLT";
+        case 29 : return "TLTU";
+        case 30 : return "TEQ";
+        case 31 : return "TNE";
+        case 32 : return "MFHI";
+        case 33 : return "MFLO";
+        case 34 : return "MTHI";
+        case 35 : return "MTLO";
+        case 36 : return "PMON";
+        case 37 : return "SYSCALL";
+        case 38 : return "BREAK";
+        case 39 : return "SPIM";
+        case 40 : return "SYNC";
+        case 41 : return "MOVCI";
+        case 42 : return "DSLL";
+        case 43 : return "DSRA";
+        case 44 : return "DSLL32";
+        case 45 : return "DSRA32";
+        case 46 : return "DSRL";
+        case 47 : return "DSRL32";
+        case 48 : return "DADD";
+        case 49 : return "DADDU";
+        case 50 : return "DSUB";
+        case 51 : return "DSUBU";
+        case 52 : return "DSLLV";
+        case 53 : return "DSRAV";
+        case 54 : return "DSRLV";
+        case 55 : return "DMULT";
+        case 56 : return "DMULTU";
+        case 57 : return "DDIV";
+        case 58 : return "DDIVU";
+        case 59 : return "MADD";
+        case 60 : return "MADDU";
+        case 61 : return "MSUB";
+        case 62 : return "MSUBU";
+        case 63 : return "MUL";
+        case 64 : return "CLO";
+        case 65 : return "CLZ";
+        case 66 : return "SDBBP";
+        case 67 : return "DIV_G_2F";
+        case 68 : return "DIVU_G_2F";
+        case 69 : return "MULT_G_2F";
+        case 70 : return "MULTU_G_2F";
+        case 71 : return "MOD_G_2F";
+        case 72 : return "MODU_G_2F";
+        case 73 : return "DCLO";
+        case 74 : return "DCLZ";
+        case 75 : return "DMULT_G_2F";
+        case 76 : return "DMULTU_G_2F";
+        case 77 : return "DDIV_G_2F";
+        case 78 : return "DDIVU_G_2F";
+        case 79 : return "DMOD_G_2F";
+        case 80 : return "DMODU_G_2F";
+        case 81 : return "EXT";
+        case 82 : return "INS";
+        case 83 : return "BSHFL";
+        case 84 : return "RDHWR";
+        case 85 : return "FORK";
+        case 86 : return "YIELD";
+        case 87 : return "DIV_G_2E";
+        case 88 : return "DIVU_G_2E";
+        case 89 : return "MOD_G_2E";
+        case 90 : return "MODU_G_2E";
+        case 91 : return "ADDUH_QB";
+        case 92 : return "ADDUH_R_QB";
+        case 93 : return "ADDQH_PH";
+        case 94 : return "ADDQH_R_PH";
+        case 95 : return "ADDQH_W";
+        case 96 : return "ADDQH_R_W";
+        case 97 : return "SUBUH_QB";
+        case 98 : return "SUBUH_R_QB";
+        case 99 : return "SUBQH_PH";
+        case 100 : return "SUBQH_R_PH";
+        case 101 : return "SUBQH_W";
+        case 102 : return "SUBQH_R_W";
+        case 103 : return "MUL_PH";
+        case 104 : return "MUL_S_PH";
+        case 105 : return "MULQ_S_W";
+        case 106 : return "MULQ_RS_W";
+        case 107 : return "LDX";
+        case 108 : return "LBUX";
+        case 109 : return "LHX";
+        case 110 : return "LWX";
+        case 111 : return "ABSQ_S_QB";
+        case 112 : return "ABSQ_S_PH";
+        case 113 : return "ABSQ_S_W";
+        case 114 : return "PRECEQ_W_PHL";
+        case 115 : return "PRECEQ_W_PHR";
+        case 116 : return "PRECEQU_PH_QBL";
+        case 117 : return "PRECEQU_PH_QBR";
+        case 118 : return "PRECEQU_PH_QBLA";
+        case 119 : return "PRECEQU_PH_QBRA";
+        case 120 : return "PRECEU_PH_QBL";
+        case 121 : return "PRECEU_PH_QBR";
+        case 122 : return "PRECEU_PH_QBLA";
+        case 123 : return "PRECEU_PH_QBRA";
+        case 124 : return "BITREV";
+        case 125 : return "REPL_QB";
+        case 126 : return "REPLV_QB";
+        case 127 : return "REPL_PH";
+        case 128 : return "REPLV_PH";
+        case 129 : return "ADDQ_PH";
+        case 130 : return "ADDQ_S_PH";
+        case 131 : return "ADDQ_S_W";
+        case 132 : return "ADDU_QB";
+        case 133 : return "ADDU_S_QB";
+        case 134 : return "ADDU_PH";
+        case 135 : return "ADDU_S_PH";
+        case 136 : return "SUBQ_PH";
+        case 137 : return "SUBQ_S_PH";
+        case 138 : return "SUBQ_S_W";
+        case 139 : return "SUBU_QB";
+        case 140 : return "SUBU_S_QB";
+        case 141 : return "SUBU_PH";
+        case 142 : return "SUBU_S_PH";
+        case 143 : return "ADDSC";
+        case 144 : return "ADDWC";
+        case 145 : return "MODSUB";
+        case 146 : return "RADDU_W_QB";
+        case 147 : return "MULEU_S_PH_QBL";
+        case 148 : return "MULEU_S_PH_QBR";
+        case 149 : return "MULQ_RS_PH";
+        case 150 : return "MULEQ_S_W_PHL";
+        case 151 : return "MULEQ_S_W_PHR";
+        case 152 : return "MULQ_S_PH";
+        case 153 : return "PRECR_SRA_PH_W";
+        case 154 : return "PRECR_SRA_R_PH_W";
+        case 155 : return "PRECR_QB_PH";
+        case 156 : return "PRECRQ_QB_PH";
+        case 157 : return "PRECRQ_PH_W";
+        case 158 : return "PRECRQ_RS_PH_W";
+        case 159 : return "PRECRQU_S_QB_PH";
+        case 160 : return "CMPU_EQ_QB";
+        case 161 : return "CMPU_LT_QB";
+        case 162 : return "CMPU_LE_QB";
+        case 163 : return "CMP_EQ_PH";
+        case 164 : return "CMP_LT_PH";
+        case 165 : return "CMP_LE_PH";
+        case 166 : return "CMPGU_EQ_QB";
+        case 167 : return "CMPGU_LT_QB";
+        case 168 : return "CMPGU_LE_QB";
+        case 169 : return "CMPGDU_EQ_QB";
+        case 170 : return "CMPGDU_LT_QB";
+        case 171 : return "CMPGDU_LE_QB";
+        case 172 : return "PICK_QB";
+        case 173 : return "PICK_PH";
+        case 174 : return "PACKRL_PH";
+        case 175 : return "SHLL_QB_DSP";
+        case 176 : return "DPAU_H_QBL";
+        case 177 : return "DPAU_H_QBR";
+        case 178 : return "DPSU_H_QBL";
+        case 179 : return "DPSU_H_QBR";
+        case 180 : return "DPA_W_PH";
+        case 181 : return "DPAX_W_PH";
+        case 182 : return "DPAQ_S_W_PH";
+        case 183 : return "DPAQX_S_W_PH";
+        case 184 : return "DPAQX_SA_W_PH";
+        case 185 : return "DPS_W_PH";
+        case 186 : return "DPSX_W_PH";
+        case 187 : return "DPSQ_S_W_PH";
+        case 188 : return "DPSQX_S_W_PH";
+        case 189 : return "DPSQX_SA_W_PH";
+        case 190 : return "MULSAQ_S_W_PH";
+        case 191 : return "DPAQ_SA_L_W";
+        case 192 : return "DPSQ_SA_L_W";
+        case 193 : return "MAQ_S_W_PHL";
+        case 194 : return "MAQ_S_W_PHR";
+        case 195 : return "MAQ_SA_W_PHL";
+        case 196 : return "MAQ_SA_W_PHR";
+        case 197 : return "MULSA_W_PH";
+        case 198 : return "INSV";
+        case 199 : return "APPEND_DSP";
+        case 200 : return "EXTR_W";
+        case 201 : return "EXTR_R_W";
+        case 202 : return "EXTR_RS_W";
+        case 203 : return "EXTR_S_H";
+        case 204 : return "EXTRV_S_H";
+        case 205 : return "EXTRV_W";
+        case 206 : return "EXTRV_R_W";
+        case 207 : return "EXTRV_RS_W";
+        case 208 : return "EXTP";
+        case 209 : return "EXTPV";
+        case 210 : return "EXTPDP";
+        case 211 : return "EXTPDPV";
+        case 212 : return "RDDSP";
+        case 213 : return "SHILO";
+        case 214 : return "SHILOV";
+        case 215 : return "MTHLIP";
+        case 216 : return "WRDSP";
+        case 217 : return "DEXTM";
+        case 218 : return "DEXTU";
+        case 219 : return "DEXT";
+        case 220 : return "DINSM";
+        case 221 : return "DINSU";
+        case 222 : return "DINS";
+        case 223 : return "DBSHFL";
+        case 224 : return "DDIV_G_2E";
+        case 225 : return "DDIVU_G_2E";
+        case 226 : return "DMULT_G_2E";
+        case 227 : return "DMULTU_G_2E";
+        case 228 : return "DMOD_G_2E";
+        case 229 : return "DMODU_G_2E";
+        case 230 : return "PRECEQ_L_PWL";
+        case 231 : return "PRECEQ_L_PWR";
+        case 232 : return "PRECEQ_PW_QHL";
+        case 233 : return "PRECEQ_PW_QHR";
+        case 234 : return "PRECEQ_PW_QHLA";
+        case 235 : return "PRECEQ_PW_QHRA";
+        case 236 : return "PRECEQU_QH_OBL";
+        case 237 : return "PRECEQU_QH_OBR";
+        case 238 : return "PRECEQU_QH_OBLA";
+        case 239 : return "PRECEQU_QH_OBRA";
+        case 240 : return "PRECEU_QH_OBL";
+        case 241 : return "PRECEU_QH_OBR";
+        case 242 : return "PRECEU_QH_OBLA";
+        case 243 : return "PRECEU_QH_OBRA";
+        case 244 : return "ABSQ_S_OB";
+        case 245 : return "ABSQ_S_PW";
+        case 246 : return "ABSQ_S_QH";
+        case 247 : return "REPL_OB";
+        case 248 : return "REPL_PW";
+        case 249 : return "REPL_QH";
+        case 250 : return "REPLV_OB";
+        case 251 : return "REPLV_PW";
+        case 252 : return "REPLV_QH";
+        case 253 : return "RADDU_L_OB";
+        case 254 : return "SUBQ_PW";
+        case 255 : return "SUBQ_S_PW";
+        case 256 : return "SUBQ_QH";
+        case 257 : return "SUBQ_S_QH";
+        case 258 : return "SUBU_OB";
+        case 259 : return "SUBU_S_OB";
+        case 260 : return "SUBU_QH";
+        case 261 : return "SUBU_S_QH";
+        case 262 : return "SUBUH_OB";
+        case 263 : return "SUBUH_R_OB";
+        case 264 : return "ADDQ_PW";
+        case 265 : return "ADDQ_S_PW";
+        case 266 : return "ADDQ_QH";
+        case 267 : return "ADDQ_S_QH";
+        case 268 : return "ADDU_OB";
+        case 269 : return "ADDU_S_OB";
+        case 270 : return "ADDU_QH";
+        case 271 : return "ADDU_S_QH";
+        case 272 : return "ADDUH_OB";
+        case 273 : return "ADDUH_R_OB";
+        case 274 : return "MULEQ_S_PW_QHL";
+        case 275 : return "MULEQ_S_PW_QHR";
+        case 276 : return "MULEU_S_QH_OBL";
+        case 277 : return "MULEU_S_QH_OBR";
+        case 278 : return "MULQ_RS_QH";
+        case 279 : return "PRECR_SRA_QH_PW";
+        case 280 : return "PRECR_SRA_R_QH_PW";
+        case 281 : return "PRECR_OB_QH";
+        case 282 : return "PRECRQ_OB_QH";
+        case 283 : return "PRECRQ_PW_L";
+        case 284 : return "PRECRQ_QH_PW";
+        case 285 : return "PRECRQ_RS_QH_PW";
+        case 286 : return "PRECRQU_S_OB_QH";
+        case 287 : return "CMPU_EQ_OB";
+        case 288 : return "CMPU_LT_OB";
+        case 289 : return "CMPU_LE_OB";
+        case 290 : return "CMP_EQ_QH";
+        case 291 : return "CMP_LT_QH";
+        case 292 : return "CMP_LE_QH";
+        case 293 : return "CMP_EQ_PW";
+        case 294 : return "CMP_LT_PW";
+        case 295 : return "CMP_LE_PW";
+        case 296 : return "CMPGDU_EQ_OB";
+        case 297 : return "CMPGDU_LT_OB";
+        case 298 : return "CMPGDU_LE_OB";
+        case 299 : return "CMPGU_EQ_OB";
+        case 300 : return "CMPGU_LT_OB";
+        case 301 : return "CMPGU_LE_OB";
+        case 302 : return "PACKRL_PW";
+        case 303 : return "PICK_OB";
+        case 304 : return "PICK_PW";
+        case 305 : return "PICK_QH";
+        case 306 : return "DAPPEND_DSP";
+        case 307 : return "DEXTP";
+        case 308 : return "DEXTPDP";
+        case 309 : return "DEXTPDPV";
+        case 310 : return "DEXTPV";
+        case 311 : return "DEXTR_L";
+        case 312 : return "DEXTR_R_L";
+        case 313 : return "DEXTR_RS_L";
+        case 314 : return "DEXTR_W";
+        case 315 : return "DEXTR_R_W";
+        case 316 : return "DEXTR_RS_W";
+        case 317 : return "DEXTR_S_H";
+        case 318 : return "DEXTRV_L";
+        case 319 : return "DEXTRV_R_L";
+        case 320 : return "DEXTRV_RS_L";
+        case 321 : return "DEXTRV_S_H";
+        case 322 : return "DEXTRV_W";
+        case 323 : return "DEXTRV_R_W";
+        case 324 : return "DEXTRV_RS_W";
+        case 325 : return "DMTHLIP";
+        case 326 : return "DSHILO";
+        case 327 : return "DSHILOV";
+        case 328 : return "DPAU_H_OBL";
+        case 329 : return "DPAU_H_OBR";
+        case 330 : return "DPSU_H_OBL";
+        case 331 : return "DPSU_H_OBR";
+        case 332 : return "DPA_W_QH";
+        case 333 : return "DPAQ_S_W_QH";
+        case 334 : return "DPS_W_QH";
+        case 335 : return "DPSQ_S_W_QH";
+        case 336 : return "MULSAQ_S_W_QH";
+        case 337 : return "DPAQ_SA_L_PW";
+        case 338 : return "DPSQ_SA_L_PW";
+        case 339 : return "MULSAQ_S_L_PW";
+        case 340 : return "MAQ_S_W_QHLL";
+        case 341 : return "MAQ_S_W_QHLR";
+        case 342 : return "MAQ_S_W_QHRL";
+        case 343 : return "MAQ_S_W_QHRR";
+        case 344 : return "MAQ_SA_W_QHLL";
+        case 345 : return "MAQ_SA_W_QHLR";
+        case 346 : return "MAQ_SA_W_QHRL";
+        case 347 : return "MAQ_SA_W_QHRR";
+        case 348 : return "MAQ_S_L_PWL";
+        case 349 : return "MAQ_S_L_PWR";
+        case 350 : return "DMADD";
+        case 351 : return "DMADDU";
+        case 352 : return "DMSUB";
+        case 353 : return "DMSUBU";
+        case 354 : return "DINSV";
+        case 355 : return "SHLL_OB_DSP";
+        case 356 : return "BLTZ";
+        case 357 : return "BLTZL";
+        case 358 : return "BGEZ";
+        case 359 : return "BGEZL";
+        case 360 : return "BLTZAL";
+        case 361 : return "BLTZALS";
+        case 362 : return "BLTZALL";
+        case 363 : return "BGEZAL";
+        case 364 : return "BGEZALS";
+        case 365 : return "BGEZALL";
+        case 366 : return "TGEI";
+        case 367 : return "TGEIU";
+        case 368 : return "TLTI";
+        case 369 : return "TLTIU";
+        case 370 : return "TEQI";
+        case 371 : return "TNEI";
+        case 372 : return "SYNCI";
+        case 373 : return "BPOSGE32";
+        case 374 : return "BPOSGE64";
+        case 375 : return "MFC0";
+        case 376 : return "MTC0";
+        case 377 : return "MFTR";
+        case 378 : return "MTTR";
+        case 379 : return "DMFC0";
+        case 380 : return "DMTC0";
+        case 381 : return "TLBWI";
+        case 382 : return "DMT";
+        case 383 : return "EMT";
+        case 384 : return "DVPE";
+        case 385 : return "EVPE";
+        case 386 : return "DI";
+        case 387 : return "EI";
+        case 388 : return "RDPGPR";
+        case 389 : return "WRPGPR";
+        case 390 : return "ADDI";
+        case 391 : return "ADDIU";
+        case 392 : return "SLTI";
+        case 393 : return "SLTIU";
+        case 394 : return "ANDI";
+        case 395 : return "LUI";
+        case 396 : return "ORI";
+        case 397 : return "XORI";
+        case 398 : return "J";
+        case 399 : return "JAL";
+        case 400 : return "BEQ";
+        case 401 : return "BEQL";
+        case 402 : return "BNE";
+        case 403 : return "BNEL";
+        case 404 : return "BLEZ";
+        case 405 : return "BLEZL";
+        case 406 : return "BGTZ";
+        case 407 : return "BGTZL";
+        case 408 : return "LB";
+        case 409 : return "LH";
+        case 410 : return "LWL";
+        case 411 : return "LW";
+        case 412 : return "LWPC";
+        case 413 : return "LBU";
+        case 414 : return "LHU";
+        case 415 : return "LWR";
+        case 416 : return "LL";
+        case 417 : return "SB";
+        case 418 : return "SH";
+        case 419 : return "SWL";
+        case 420 : return "SW";
+        case 421 : return "SWR";
+        case 422 : return "SC";
+        case 423 : return "CACHE";
+        case 424 : return "PREF";
+        case 425 : return "LWC1";
+        case 426 : return "LDC1";
+        case 427 : return "SWC1";
+        case 428 : return "SDC1";
+        case 429 : return "MFHC1";
+        case 430 : return "MTHC1";
+        case 431 : return "MFC1";
+        case 432 : return "CFC1";
+        case 433 : return "MTC1";
+        case 434 : return "CTC1";
+        case 435 : return "DMFC1";
+        case 436 : return "DMTC1";
+        case 437 : return "BC1ANY2";
+        case 438 : return "BC1ANY4";
+        case 439 : return "BC1";
+        case 440 : return "S_FMT";
+        case 441 : return "D_FMT";
+        case 442 : return "W_FMT";
+        case 443 : return "L_FMT";
+        case 444 : return "PS_FMT";
+        case 445 : return "LWC2";
+        case 446 : return "LDC2";
+        case 447 : return "SWC2";
+        case 448 : return "SDC2";
+        case 449 : return "CP2";
+        case 450 : return "LWXC1";
+        case 451 : return "LDXC1";
+        case 452 : return "LUXC1";
+        case 453 : return "SWXC1";
+        case 454 : return "SDXC1";
+        case 455 : return "SUXC1";
+        case 456 : return "PREFX";
+        case 457 : return "ALNV_PS";
+        case 458 : return "MADD_S";
+        case 459 : return "MADD_D";
+        case 460 : return "MADD_PS";
+        case 461 : return "MSUB_S";
+        case 462 : return "MSUB_D";
+        case 463 : return "MSUB_PS";
+        case 464 : return "NMADD_S";
+        case 465 : return "NMADD_D";
+        case 466 : return "NMADD_PS";
+        case 467 : return "NMSUB_S";
+        case 468 : return "NMSUB_D";
+        case 469 : return "NMSUB_PS";
+        case 470 : return "LWU";
+        case 471 : return "LDL";
+        case 472 : return "LDR";
+        case 473 : return "LLD";
+        case 474 : return "LD";
+        case 475 : return "SDL";
+        case 476 : return "SDR";
+        case 477 : return "SD";
+        case 478 : return "SCD";
+        case 479 : return "DADDI";
+        case 480 : return "DADDIU";
+        case 481 : return "JALX";
+        case 482 : return "MDMX";
+        case 483 : return "MOVE";
+        case 484 : return "TLBWR";
+        case 485 : return "TLBP";
+        case 486 : return "TLBR";
+        case 487 : return "ERET";
+        case 488 : return "DERET";
+        case 489 : return "WAIT";
+
+        default : return "Invalid instruction counter index!";
+    }
+}
+
+void dump_instruction_stats(CPUMIPSState *env)
+{
+    int index;
+    uint64_t sum = 0;
+
+    if (!enable_mips_icount_stats) return;
+
+    fprintf(icount_logfile, "\n=================================================\n");
+    fprintf(icount_logfile, "Instruction Statistics\n");
+    fprintf(icount_logfile, "=================================================\n");
+    for(index=0; index<=489; index++) {
+        if (env->icount[index] != 0) {
+            fprintf(icount_logfile, "%-30s : %16" PRId64 "\n",
+                decode_icount_index(index), env->icount[index]);
+            sum += env->icount[index];
+        }
+    }
+    fprintf(icount_logfile, "\nSum                            : %16" PRId64 "\n", sum);
+    fprintf(icount_logfile, "\nUnrecognized opcodes           : %16" PRId64 "\n", env->invalid_opc);
+    fprintf(icount_logfile, "=================================================\n\n");
+}
+
+void reset_instruction_counters(CPUMIPSState *env)
+{
+    memset(env->icount, 0, sizeof(env->icount));
+    env->invalid_opc = 0;
+}
 
 /*****************************************************************************/
 /* Exceptions processing helpers */
diff --git a/target-mips/translate.c b/target-mips/translate.c
index 5626647..35265d5 100644
--- a/target-mips/translate.c
+++ b/target-mips/translate.c
@@ -866,20 +866,22 @@ enum {
 #define MASK_CP0(op)       MASK_OP_MAJOR(op) | (op & (0x1F << 21))
 
 enum {
-    OPC_MFC0     = (0x00 << 21) | OPC_CP0,
-    OPC_DMFC0    = (0x01 << 21) | OPC_CP0,
-    OPC_MFHC0    = (0x02 << 21) | OPC_CP0,
-    OPC_MTC0     = (0x04 << 21) | OPC_CP0,
-    OPC_DMTC0    = (0x05 << 21) | OPC_CP0,
-    OPC_MTHC0    = (0x06 << 21) | OPC_CP0,
-    OPC_MFTR     = (0x08 << 21) | OPC_CP0,
-    OPC_RDPGPR   = (0x0A << 21) | OPC_CP0,
-    OPC_MFMC0    = (0x0B << 21) | OPC_CP0,
-    OPC_MTTR     = (0x0C << 21) | OPC_CP0,
-    OPC_WRPGPR   = (0x0E << 21) | OPC_CP0,
-    OPC_C0       = (0x10 << 21) | OPC_CP0,
-    OPC_C0_FIRST = (0x10 << 21) | OPC_CP0,
-    OPC_C0_LAST  = (0x1F << 21) | OPC_CP0,
+    OPC_MFC0            = (0x00 << 21) | OPC_CP0,
+    OPC_DMFC0           = (0x01 << 21) | OPC_CP0,
+    OPC_MFHC0           = (0x02 << 21) | OPC_CP0,
+    OPC_CACHE_START     = (0x02 << 21) | OPC_CP0,
+    OPC_CACHE_STOP      = (0x03 << 21) | OPC_CP0,
+    OPC_MTC0            = (0x04 << 21) | OPC_CP0,
+    OPC_DMTC0           = (0x05 << 21) | OPC_CP0,
+    OPC_MTHC0           = (0x06 << 21) | OPC_CP0,
+    OPC_MFTR            = (0x08 << 21) | OPC_CP0,
+    OPC_RDPGPR          = (0x0A << 21) | OPC_CP0,
+    OPC_MFMC0           = (0x0B << 21) | OPC_CP0,
+    OPC_MTTR            = (0x0C << 21) | OPC_CP0,
+    OPC_WRPGPR          = (0x0E << 21) | OPC_CP0,
+    OPC_C0              = (0x10 << 21) | OPC_CP0,
+    OPC_C0_FIRST        = (0x10 << 21) | OPC_CP0,
+    OPC_C0_LAST         = (0x1F << 21) | OPC_CP0,
 };
 
 /* MFMC0 opcodes */
@@ -1495,6 +1497,656 @@ static const char * const msaregnames[] = {
         }                                                                     \
     } while (0)
 
+void do_instruction_count(CPUMIPSState *env, uint32_t opcode)
+{
+    uint32_t op, op1, op2;
+    int rs, rt;
+
+    rs = (opcode >> 21) & 0x1f;
+    rt = (opcode >> 16) & 0x1f;
+
+    op = MASK_OP_MAJOR(opcode);
+    switch (op) {
+    case OPC_SPECIAL:
+        op1 = MASK_SPECIAL(opcode);
+        switch (op1) {
+        case OPC_SLL: env->icount[0]++; break;
+        case OPC_SRA: env->icount[1]++; break;
+        case OPC_SRL: env->icount[2]++; break;
+        case OPC_MOVN: env->icount[3]++; break;
+        case OPC_MOVZ: env->icount[4]++; break;
+        case OPC_ADD: env->icount[5]++; break;
+        case OPC_ADDU: env->icount[6]++; break;
+        case OPC_SUB: env->icount[7]++; break;
+        case OPC_SUBU: env->icount[8]++; break;
+        case OPC_SLLV: env->icount[9]++; break;
+        case OPC_SRAV: env->icount[10]++; break;
+        case OPC_SRLV: env->icount[11]++; break;
+        case OPC_SLT: env->icount[12]++; break;
+        case OPC_SLTU: env->icount[13]++; break;
+        case OPC_AND: env->icount[14]++; break;
+        case OPC_OR:
+            if (rs != 0 && rt == 0) {
+                env->icount[483]++;
+            } else {
+                env->icount[15]++;
+            }
+            break;
+        case OPC_NOR: env->icount[16]++; break;
+        case OPC_XOR: env->icount[17]++; break;
+        case OPC_MULT: env->icount[18]++; break;
+        case OPC_MULTU: env->icount[19]++; break;
+        case OPC_DIV: env->icount[20]++; break;
+        case OPC_DIVU: env->icount[21]++; break;
+        case OPC_JR: env->icount[22]++; break;
+        case OPC_JALR: env->icount[23]++; break;
+        case OPC_TGE: env->icount[26]++; break;
+        case OPC_TGEU: env->icount[27]++; break;
+        case OPC_TLT: env->icount[28]++; break;
+        case OPC_TLTU: env->icount[29]++; break;
+        case OPC_TEQ: env->icount[30]++; break;
+        case OPC_TNE: env->icount[31]++; break;
+        case OPC_MFHI: env->icount[32]++; break;
+        case OPC_MFLO: env->icount[33]++; break;
+        case OPC_MTHI: env->icount[34]++; break;
+        case OPC_MTLO: env->icount[35]++; break;
+        case OPC_PMON: env->icount[36]++; break;
+        case OPC_SYSCALL: env->icount[37]++; break;
+        case OPC_BREAK: env->icount[38]++; break;
+        case OPC_SPIM: env->icount[39]++; break;
+        case OPC_SYNC: env->icount[40]++; break;
+        case OPC_MOVCI: env->icount[41]++; break;
+        case OPC_DSLL: env->icount[42]++; break;
+        case OPC_DSRA: env->icount[43]++; break;
+        case OPC_DSLL32: env->icount[44]++; break;
+        case OPC_DSRA32: env->icount[45]++; break;
+        case OPC_DSRL: env->icount[46]++; break;
+        case OPC_DSRL32: env->icount[47]++; break;
+        case OPC_DADD: env->icount[48]++; break;
+        case OPC_DADDU: env->icount[49]++; break;
+        case OPC_DSUB: env->icount[50]++; break;
+        case OPC_DSUBU: env->icount[51]++; break;
+        case OPC_DSLLV: env->icount[52]++; break;
+        case OPC_DSRAV: env->icount[53]++; break;
+        case OPC_DSRLV: env->icount[54]++; break;
+        case OPC_DMULT: env->icount[55]++; break;
+        case OPC_DMULTU: env->icount[56]++; break;
+        case OPC_DDIV: env->icount[57]++; break;
+        case OPC_DDIVU: env->icount[58]++; break;
+        default: env->invalid_opc++; break;
+    }       /* Invalid */
+    break;
+    case OPC_SPECIAL2:
+        op1 = MASK_SPECIAL2(opcode);
+        switch (op1) {
+        case OPC_MADD: env->icount[59]++; break;
+        case OPC_MADDU: env->icount[60]++; break;
+        case OPC_MSUB: env->icount[61]++; break;
+        case OPC_MSUBU: env->icount[62]++; break;
+        case OPC_MUL: env->icount[63]++; break;
+        case OPC_CLO: env->icount[64]++; break;
+        case OPC_CLZ: env->icount[65]++; break;
+        case OPC_SDBBP: env->icount[66]++; break;
+        case OPC_DIV_G_2F: env->icount[67]++; break;
+        case OPC_DIVU_G_2F: env->icount[68]++; break;
+        case OPC_MULT_G_2F: env->icount[69]++; break;
+        case OPC_MULTU_G_2F: env->icount[70]++; break;
+        case OPC_MOD_G_2F: env->icount[71]++; break;
+        case OPC_MODU_G_2F: env->icount[72]++; break;
+        case OPC_DCLO: env->icount[73]++; break;
+        case OPC_DCLZ: env->icount[74]++; break;
+        case OPC_DMULT_G_2F: env->icount[75]++; break;
+        case OPC_DMULTU_G_2F: env->icount[76]++; break;
+        case OPC_DDIV_G_2F: env->icount[77]++; break;
+        case OPC_DDIVU_G_2F: env->icount[78]++; break;
+        case OPC_DMOD_G_2F: env->icount[79]++; break;
+        case OPC_DMODU_G_2F: env->icount[80]++; break;
+        default: env->invalid_opc++; break;
+    }
+    break;
+    case OPC_SPECIAL3:
+        op1 = MASK_SPECIAL3(opcode);
+        switch (op1) {
+        case OPC_EXT: env->icount[81]++; break;
+        case OPC_INS: env->icount[82]++; break;
+        case OPC_BSHFL: env->icount[83]++; break;
+        case OPC_RDHWR: env->icount[84]++; break;
+        case OPC_FORK: env->icount[85]++; break;
+        case OPC_YIELD: env->icount[86]++; break;
+        case OPC_DIV_G_2E: env->icount[87]++; break;
+        case OPC_DIVU_G_2E: env->icount[88]++; break;
+        case OPC_MOD_G_2E: env->icount[89]++; break;
+        case OPC_MODU_G_2E: env->icount[90]++; break;
+        case OPC_MULT_G_2E ... OPC_MULTU_G_2E:
+            op2 = MASK_ADDUH_QB(opcode);
+            switch (op2) {
+            case OPC_ADDUH_QB: env->icount[91]++; break;
+            case OPC_ADDUH_R_QB: env->icount[92]++; break;
+            case OPC_ADDQH_PH: env->icount[93]++; break;
+            case OPC_ADDQH_R_PH: env->icount[94]++; break;
+            case OPC_ADDQH_W: env->icount[95]++; break;
+            case OPC_ADDQH_R_W: env->icount[96]++; break;
+            case OPC_SUBUH_QB: env->icount[97]++; break;
+            case OPC_SUBUH_R_QB: env->icount[98]++; break;
+            case OPC_SUBQH_PH: env->icount[99]++; break;
+            case OPC_SUBQH_R_PH: env->icount[100]++; break;
+            case OPC_SUBQH_W: env->icount[101]++; break;
+            case OPC_SUBQH_R_W: env->icount[102]++; break;
+            case OPC_MUL_PH: env->icount[103]++; break;
+            case OPC_MUL_S_PH: env->icount[104]++; break;
+            case OPC_MULQ_S_W: env->icount[105]++; break;
+            case OPC_MULQ_RS_W: env->icount[106]++; break;
+            default: env->invalid_opc++; break;
+            }
+            break;
+        case OPC_LX_DSP:
+            op2 = MASK_LX(opcode);
+            switch (op2) {
+            case OPC_LDX: env->icount[107]++; break;
+            case OPC_LBUX: env->icount[108]++; break;
+            case OPC_LHX: env->icount[109]++; break;
+            case OPC_LWX: env->icount[110]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_ABSQ_S_PH_DSP:
+            op2 = MASK_ABSQ_S_PH(opcode);
+            switch (op2) {
+            case OPC_ABSQ_S_QB: env->icount[111]++; break;
+            case OPC_ABSQ_S_PH: env->icount[112]++; break;
+            case OPC_ABSQ_S_W: env->icount[113]++; break;
+            case OPC_PRECEQ_W_PHL: env->icount[114]++; break;
+            case OPC_PRECEQ_W_PHR: env->icount[115]++; break;
+            case OPC_PRECEQU_PH_QBL: env->icount[116]++; break;
+            case OPC_PRECEQU_PH_QBR: env->icount[117]++; break;
+            case OPC_PRECEQU_PH_QBLA: env->icount[118]++; break;
+            case OPC_PRECEQU_PH_QBRA: env->icount[119]++; break;
+            case OPC_PRECEU_PH_QBL: env->icount[120]++; break;
+            case OPC_PRECEU_PH_QBR: env->icount[121]++; break;
+            case OPC_PRECEU_PH_QBLA: env->icount[122]++; break;
+            case OPC_PRECEU_PH_QBRA: env->icount[123]++; break;
+            case OPC_BITREV: env->icount[124]++; break;
+            case OPC_REPL_QB: env->icount[125]++; break;
+            case OPC_REPLV_QB: env->icount[126]++; break;
+            case OPC_REPL_PH: env->icount[127]++; break;
+            case OPC_REPLV_PH: env->icount[128]++; break;
+            default: env->invalid_opc++; break;
+            }
+        break;
+        case OPC_ADDU_QB_DSP:
+            op2 = MASK_ADDU_QB(opcode);
+            switch (op2) {
+            case OPC_ADDQ_PH: env->icount[129]++; break;
+            case OPC_ADDQ_S_PH: env->icount[130]++; break;
+            case OPC_ADDQ_S_W: env->icount[131]++; break;
+            case OPC_ADDU_QB: env->icount[132]++; break;
+            case OPC_ADDU_S_QB: env->icount[133]++; break;
+            case OPC_ADDU_PH: env->icount[134]++; break;
+            case OPC_ADDU_S_PH: env->icount[135]++; break;
+            case OPC_SUBQ_PH: env->icount[136]++; break;
+            case OPC_SUBQ_S_PH: env->icount[137]++; break;
+            case OPC_SUBQ_S_W: env->icount[138]++; break;
+            case OPC_SUBU_QB: env->icount[139]++; break;
+            case OPC_SUBU_S_QB: env->icount[140]++; break;
+            case OPC_SUBU_PH: env->icount[141]++; break;
+            case OPC_SUBU_S_PH: env->icount[142]++; break;
+            case OPC_ADDSC: env->icount[143]++; break;
+            case OPC_ADDWC: env->icount[144]++; break;
+            case OPC_MODSUB: env->icount[145]++; break;
+            case OPC_RADDU_W_QB: env->icount[146]++; break;
+            case OPC_MULEU_S_PH_QBL: env->icount[147]++; break;
+            case OPC_MULEU_S_PH_QBR: env->icount[148]++; break;
+            case OPC_MULQ_RS_PH: env->icount[149]++; break;
+            case OPC_MULEQ_S_W_PHL: env->icount[150]++; break;
+            case OPC_MULEQ_S_W_PHR: env->icount[151]++; break;
+            case OPC_MULQ_S_PH: env->icount[152]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_CMPU_EQ_QB_DSP:
+            op2 = MASK_CMPU_EQ_QB(opcode);
+            switch (op2) {
+            case OPC_PRECR_SRA_PH_W: env->icount[153]++; break;
+            case OPC_PRECR_SRA_R_PH_W: env->icount[154]++; break;
+            case OPC_PRECR_QB_PH: env->icount[155]++; break;
+            case OPC_PRECRQ_QB_PH: env->icount[156]++; break;
+            case OPC_PRECRQ_PH_W: env->icount[157]++; break;
+            case OPC_PRECRQ_RS_PH_W: env->icount[158]++; break;
+            case OPC_PRECRQU_S_QB_PH: env->icount[159]++; break;
+            case OPC_CMPU_EQ_QB: env->icount[160]++; break;
+            case OPC_CMPU_LT_QB: env->icount[161]++; break;
+            case OPC_CMPU_LE_QB: env->icount[162]++; break;
+            case OPC_CMP_EQ_PH: env->icount[163]++; break;
+            case OPC_CMP_LT_PH: env->icount[164]++; break;
+            case OPC_CMP_LE_PH: env->icount[165]++; break;
+            case OPC_CMPGU_EQ_QB: env->icount[166]++; break;
+            case OPC_CMPGU_LT_QB: env->icount[167]++; break;
+            case OPC_CMPGU_LE_QB: env->icount[168]++; break;
+            case OPC_CMPGDU_EQ_QB: env->icount[169]++; break;
+            case OPC_CMPGDU_LT_QB: env->icount[170]++; break;
+            case OPC_CMPGDU_LE_QB: env->icount[171]++; break;
+            case OPC_PICK_QB: env->icount[172]++; break;
+            case OPC_PICK_PH: env->icount[173]++; break;
+            case OPC_PACKRL_PH: env->icount[174]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_SHLL_QB_DSP: env->icount[175]++; break;
+        case OPC_DPA_W_PH_DSP:
+            op2 = MASK_DPA_W_PH(opcode);
+            switch (op2) {
+            case OPC_DPAU_H_QBL: env->icount[176]++; break;
+            case OPC_DPAU_H_QBR: env->icount[177]++; break;
+            case OPC_DPSU_H_QBL: env->icount[178]++; break;
+            case OPC_DPSU_H_QBR: env->icount[179]++; break;
+            case OPC_DPA_W_PH: env->icount[180]++; break;
+            case OPC_DPAX_W_PH: env->icount[181]++; break;
+            case OPC_DPAQ_S_W_PH: env->icount[182]++; break;
+            case OPC_DPAQX_S_W_PH: env->icount[183]++; break;
+            case OPC_DPAQX_SA_W_PH: env->icount[184]++; break;
+            case OPC_DPS_W_PH: env->icount[185]++; break;
+            case OPC_DPSX_W_PH: env->icount[186]++; break;
+            case OPC_DPSQ_S_W_PH: env->icount[187]++; break;
+            case OPC_DPSQX_S_W_PH: env->icount[188]++; break;
+            case OPC_DPSQX_SA_W_PH: env->icount[189]++; break;
+            case OPC_MULSAQ_S_W_PH: env->icount[190]++; break;
+            case OPC_DPAQ_SA_L_W: env->icount[191]++; break;
+            case OPC_DPSQ_SA_L_W: env->icount[192]++; break;
+            case OPC_MAQ_S_W_PHL: env->icount[193]++; break;
+            case OPC_MAQ_S_W_PHR: env->icount[194]++; break;
+            case OPC_MAQ_SA_W_PHL: env->icount[195]++; break;
+            case OPC_MAQ_SA_W_PHR: env->icount[196]++; break;
+            case OPC_MULSA_W_PH: env->icount[197]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_INSV_DSP:
+            op2 = MASK_INSV(opcode);
+            switch (op2) {
+            case OPC_INSV: env->icount[198]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_APPEND_DSP: env->icount[199]++; break;
+        case OPC_EXTR_W_DSP:
+            op2 = MASK_EXTR_W(opcode);
+            switch (op2) {
+            case OPC_EXTR_W: env->icount[200]++; break;
+            case OPC_EXTR_R_W: env->icount[201]++; break;
+            case OPC_EXTR_RS_W: env->icount[202]++; break;
+            case OPC_EXTR_S_H: env->icount[203]++; break;
+            case OPC_EXTRV_S_H: env->icount[204]++; break;
+            case OPC_EXTRV_W: env->icount[205]++; break;
+            case OPC_EXTRV_R_W: env->icount[206]++; break;
+            case OPC_EXTRV_RS_W: env->icount[207]++; break;
+            case OPC_EXTP: env->icount[208]++; break;
+            case OPC_EXTPV: env->icount[209]++; break;
+            case OPC_EXTPDP: env->icount[210]++; break;
+            case OPC_EXTPDPV: env->icount[211]++; break;
+            case OPC_RDDSP: env->icount[212]++; break;
+            case OPC_SHILO: env->icount[213]++; break;
+            case OPC_SHILOV: env->icount[214]++; break;
+            case OPC_MTHLIP: env->icount[215]++; break;
+            case OPC_WRDSP: env->icount[216]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_DEXTM: env->icount[217]++; break;
+        case OPC_DEXTU: env->icount[218]++; break;
+        case OPC_DEXT: env->icount[219]++; break;
+        case OPC_DINSM: env->icount[220]++; break;
+        case OPC_DINSU: env->icount[221]++; break;
+        case OPC_DINS: env->icount[222]++; break;
+        case OPC_DBSHFL: env->icount[223]++; break;
+        case OPC_DDIV_G_2E:  env->icount[224]++; break;
+        case OPC_DDIVU_G_2E: env->icount[225]++; break;
+        case OPC_DMULT_G_2E: env->icount[226]++; break;
+        case OPC_DMULTU_G_2E: env->icount[227]++; break;
+        case OPC_DMOD_G_2E: env->icount[228]++; break;
+        case OPC_DMODU_G_2E: env->icount[229]++; break;
+        case OPC_ABSQ_S_QH_DSP:
+            op2 = MASK_ABSQ_S_QH(opcode);
+            switch (op2) {
+            case OPC_PRECEQ_L_PWL: env->icount[230]++; break;
+            case OPC_PRECEQ_L_PWR: env->icount[231]++; break;
+            case OPC_PRECEQ_PW_QHL: env->icount[232]++; break;
+            case OPC_PRECEQ_PW_QHR: env->icount[233]++; break;
+            case OPC_PRECEQ_PW_QHLA: env->icount[234]++; break;
+            case OPC_PRECEQ_PW_QHRA: env->icount[235]++; break;
+            case OPC_PRECEQU_QH_OBL: env->icount[236]++; break;
+            case OPC_PRECEQU_QH_OBR: env->icount[237]++; break;
+            case OPC_PRECEQU_QH_OBLA: env->icount[238]++; break;
+            case OPC_PRECEQU_QH_OBRA: env->icount[239]++; break;
+            case OPC_PRECEU_QH_OBL: env->icount[240]++; break;
+            case OPC_PRECEU_QH_OBR: env->icount[241]++; break;
+            case OPC_PRECEU_QH_OBLA: env->icount[242]++; break;
+            case OPC_PRECEU_QH_OBRA: env->icount[243]++; break;
+            case OPC_ABSQ_S_OB: env->icount[244]++; break;
+            case OPC_ABSQ_S_PW: env->icount[245]++; break;
+            case OPC_ABSQ_S_QH: env->icount[246]++; break;
+            case OPC_REPL_OB: env->icount[247]++; break;
+            case OPC_REPL_PW: env->icount[248]++; break;
+            case OPC_REPL_QH: env->icount[249]++; break;
+            case OPC_REPLV_OB: env->icount[250]++; break;
+            case OPC_REPLV_PW: env->icount[251]++; break;
+            case OPC_REPLV_QH: env->icount[252]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_ADDU_OB_DSP:
+            op2 = MASK_ADDU_OB(opcode);
+            switch (op2) {
+            case OPC_RADDU_L_OB: env->icount[253]++; break;
+            case OPC_SUBQ_PW: env->icount[254]++; break;
+            case OPC_SUBQ_S_PW: env->icount[255]++; break;
+            case OPC_SUBQ_QH: env->icount[256]++; break;
+            case OPC_SUBQ_S_QH: env->icount[257]++; break;
+            case OPC_SUBU_OB: env->icount[258]++; break;
+            case OPC_SUBU_S_OB: env->icount[259]++; break;
+            case OPC_SUBU_QH: env->icount[260]++; break;
+            case OPC_SUBU_S_QH: env->icount[261]++; break;
+            case OPC_SUBUH_OB: env->icount[262]++; break;
+            case OPC_SUBUH_R_OB: env->icount[263]++; break;
+            case OPC_ADDQ_PW: env->icount[264]++; break;
+            case OPC_ADDQ_S_PW: env->icount[265]++; break;
+            case OPC_ADDQ_QH: env->icount[266]++; break;
+            case OPC_ADDQ_S_QH: env->icount[267]++; break;
+            case OPC_ADDU_OB: env->icount[268]++; break;
+            case OPC_ADDU_S_OB: env->icount[269]++; break;
+            case OPC_ADDU_QH: env->icount[270]++; break;
+            case OPC_ADDU_S_QH: env->icount[271]++; break;
+            case OPC_ADDUH_OB: env->icount[272]++; break;
+            case OPC_ADDUH_R_OB: env->icount[273]++; break;
+            case OPC_MULEQ_S_PW_QHL: env->icount[274]++; break;
+            case OPC_MULEQ_S_PW_QHR: env->icount[275]++; break;
+            case OPC_MULEU_S_QH_OBL: env->icount[276]++; break;
+            case OPC_MULEU_S_QH_OBR: env->icount[277]++; break;
+            case OPC_MULQ_RS_QH: env->icount[278]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_CMPU_EQ_OB_DSP:
+            op2 = MASK_CMPU_EQ_OB(opcode);
+            switch (op2) {
+            case OPC_PRECR_SRA_QH_PW: env->icount[279]++; break;
+            case OPC_PRECR_SRA_R_QH_PW: env->icount[280]++; break;
+            case OPC_PRECR_OB_QH: env->icount[281]++; break;
+            case OPC_PRECRQ_OB_QH: env->icount[282]++; break;
+            case OPC_PRECRQ_PW_L: env->icount[283]++; break;
+            case OPC_PRECRQ_QH_PW: env->icount[284]++; break;
+            case OPC_PRECRQ_RS_QH_PW: env->icount[285]++; break;
+            case OPC_PRECRQU_S_OB_QH: env->icount[286]++; break;
+            case OPC_CMPU_EQ_OB: env->icount[287]++; break;
+            case OPC_CMPU_LT_OB: env->icount[288]++; break;
+            case OPC_CMPU_LE_OB: env->icount[289]++; break;
+            case OPC_CMP_EQ_QH: env->icount[290]++; break;
+            case OPC_CMP_LT_QH: env->icount[291]++; break;
+            case OPC_CMP_LE_QH: env->icount[292]++; break;
+            case OPC_CMP_EQ_PW: env->icount[293]++; break;
+            case OPC_CMP_LT_PW: env->icount[294]++; break;
+            case OPC_CMP_LE_PW: env->icount[295]++; break;
+            case OPC_CMPGDU_EQ_OB: env->icount[296]++; break;
+            case OPC_CMPGDU_LT_OB: env->icount[297]++; break;
+            case OPC_CMPGDU_LE_OB: env->icount[298]++; break;
+            case OPC_CMPGU_EQ_OB: env->icount[299]++; break;
+            case OPC_CMPGU_LT_OB: env->icount[300]++; break;
+            case OPC_CMPGU_LE_OB: env->icount[301]++; break;
+            case OPC_PACKRL_PW: env->icount[302]++; break;
+            case OPC_PICK_OB: env->icount[303]++; break;
+            case OPC_PICK_PW: env->icount[304]++; break;
+            case OPC_PICK_QH: env->icount[305]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_DAPPEND_DSP: env->icount[306]++; break;
+        case OPC_DEXTR_W_DSP:
+            op2 = MASK_DEXTR_W(opcode);
+            switch (op2) {
+            case OPC_DEXTP: env->icount[307]++; break;
+            case OPC_DEXTPDP: env->icount[308]++; break;
+            case OPC_DEXTPDPV: env->icount[309]++; break;
+            case OPC_DEXTPV: env->icount[310]++; break;
+            case OPC_DEXTR_L: env->icount[311]++; break;
+            case OPC_DEXTR_R_L: env->icount[312]++; break;
+            case OPC_DEXTR_RS_L: env->icount[313]++; break;
+            case OPC_DEXTR_W: env->icount[314]++; break;
+            case OPC_DEXTR_R_W: env->icount[315]++; break;
+            case OPC_DEXTR_RS_W: env->icount[316]++; break;
+            case OPC_DEXTR_S_H: env->icount[317]++; break;
+            case OPC_DEXTRV_L: env->icount[318]++; break;
+            case OPC_DEXTRV_R_L: env->icount[319]++; break;
+            case OPC_DEXTRV_RS_L: env->icount[320]++; break;
+            case OPC_DEXTRV_S_H: env->icount[321]++; break;
+            case OPC_DEXTRV_W: env->icount[322]++; break;
+            case OPC_DEXTRV_R_W: env->icount[323]++; break;
+            case OPC_DEXTRV_RS_W: env->icount[324]++; break;
+            case OPC_DMTHLIP: env->icount[325]++; break;
+            case OPC_DSHILO: env->icount[326]++; break;
+            case OPC_DSHILOV: env->icount[327]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_DPAQ_W_QH_DSP:
+            op2 = MASK_DPAQ_W_QH(opcode);
+            switch (op2) {
+            case OPC_DPAU_H_OBL: env->icount[328]++; break;
+            case OPC_DPAU_H_OBR: env->icount[329]++; break;
+            case OPC_DPSU_H_OBL: env->icount[330]++; break;
+            case OPC_DPSU_H_OBR: env->icount[331]++; break;
+            case OPC_DPA_W_QH: env->icount[332]++; break;
+            case OPC_DPAQ_S_W_QH: env->icount[333]++; break;
+            case OPC_DPS_W_QH: env->icount[334]++; break;
+            case OPC_DPSQ_S_W_QH: env->icount[335]++; break;
+            case OPC_MULSAQ_S_W_QH: env->icount[336]++; break;
+            case OPC_DPAQ_SA_L_PW: env->icount[337]++; break;
+            case OPC_DPSQ_SA_L_PW: env->icount[338]++; break;
+            case OPC_MULSAQ_S_L_PW: env->icount[339]++; break;
+            case OPC_MAQ_S_W_QHLL: env->icount[340]++; break;
+            case OPC_MAQ_S_W_QHLR: env->icount[341]++; break;
+            case OPC_MAQ_S_W_QHRL: env->icount[342]++; break;
+            case OPC_MAQ_S_W_QHRR: env->icount[343]++; break;
+            case OPC_MAQ_SA_W_QHLL: env->icount[344]++; break;
+            case OPC_MAQ_SA_W_QHLR: env->icount[345]++; break;
+            case OPC_MAQ_SA_W_QHRL: env->icount[346]++; break;
+            case OPC_MAQ_SA_W_QHRR: env->icount[347]++; break;
+            case OPC_MAQ_S_L_PWL: env->icount[348]++; break;
+            case OPC_MAQ_S_L_PWR: env->icount[349]++; break;
+            case OPC_DMADD: env->icount[350]++; break;
+            case OPC_DMADDU: env->icount[351]++; break;
+            case OPC_DMSUB: env->icount[352]++; break;
+            case OPC_DMSUBU: env->icount[353]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_DINSV_DSP:
+            op2 = MASK_INSV(opcode);
+            switch (op2) {
+            case OPC_DINSV: env->icount[354]++; break;
+            default: env->invalid_opc++; break;
+            }           /* Invalid */
+        break;
+        case OPC_SHLL_OB_DSP: env->icount[355]++; break;
+        default: env->invalid_opc++; break;
+        }       /* Invalid */
+    break;
+    case OPC_REGIMM:
+        op1 = MASK_REGIMM(opcode);
+        switch (op1) {
+        case OPC_BLTZ: env->icount[356]++; break;
+        case OPC_BLTZL: env->icount[357]++; break;
+        case OPC_BGEZ: env->icount[358]++; break;
+        case OPC_BGEZL: env->icount[359]++; break;
+        case OPC_BLTZAL: env->icount[360]++; break;
+        case OPC_BLTZALL: env->icount[362]++; break;
+        case OPC_BGEZAL: env->icount[363]++; break;
+        case OPC_BGEZALL: env->icount[365]++; break;
+        case OPC_TGEI: env->icount[366]++; break;
+        case OPC_TGEIU: env->icount[367]++; break;
+        case OPC_TLTI: env->icount[368]++; break;
+        case OPC_TLTIU: env->icount[369]++; break;
+        case OPC_TEQI: env->icount[370]++; break;
+        case OPC_TNEI: env->icount[371]++; break;
+        case OPC_SYNCI: env->icount[372]++; break;
+        case OPC_BPOSGE32: env->icount[373]++; break;
+        case OPC_BPOSGE64: env->icount[374]++; break;
+        default: env->invalid_opc++; break;
+        }       /* Invalid */
+    break;
+    case OPC_CP0:
+        op1 = MASK_CP0(opcode);
+        switch (op1) {
+        case OPC_MFC0: env->icount[375]++; break;
+        case OPC_MTC0: env->icount[376]++; break;
+        case OPC_MFTR: env->icount[377]++; break;
+        case OPC_MTTR: env->icount[378]++; break;
+        case OPC_DMFC0: env->icount[379]++; break;
+        case OPC_DMTC0: env->icount[380]++; break;
+        case OPC_C0_FIRST ... OPC_C0_LAST:
+            switch (MASK_C0(opcode)) {
+            case OPC_MFC0: env->icount[375]++; break;
+            case OPC_MTC0: env->icount[376]++; break;
+            case OPC_DMFC0: env->icount[379]++; break;
+            case OPC_DMTC0: env->icount[380]++; break;
+            case OPC_MFTR: env->icount[377]++; break;
+            case OPC_MTTR: env->icount[378]++; break;
+            case OPC_TLBWI: env->icount[381]++; break;
+            case OPC_TLBWR: env->icount[484]++; break;
+            case OPC_TLBP: env->icount[485]++; break;
+            case OPC_TLBR: env->icount[486]++; break;
+            case OPC_ERET: env->icount[487]++; break;
+            case OPC_DERET: env->icount[488]++; break;
+            case OPC_WAIT: env->icount[489]++; break;
+            default: env->invalid_opc++; break;
+            }
+            break;
+        case OPC_MFMC0:
+            op2 = MASK_MFMC0(opcode);
+            switch (op2) {
+            case OPC_DMT: env->icount[382]++; break;
+            case OPC_EMT: env->icount[383]++; break;
+            case OPC_DVPE: env->icount[384]++; break;
+            case OPC_EVPE: env->icount[385]++; break;
+            case OPC_DI: env->icount[386]++; break;
+                /* Stop translation as we may have switched the execution mode */
+            case OPC_EI: env->icount[387]++; break;
+                /* Stop translation as we may have switched the execution mode */
+            default: env->invalid_opc++; break;
+            }               /* Invalid */
+            break;
+        case OPC_RDPGPR: env->icount[388]++; break;
+        case OPC_WRPGPR: env->icount[389]++; break;
+        default: env->invalid_opc++; break;
+        }
+    break;
+    case OPC_ADDI: env->icount[390]++; break;
+    case OPC_ADDIU: env->icount[391]++; break;
+    case OPC_SLTI: env->icount[392]++; break;
+    case OPC_SLTIU: env->icount[393]++; break;
+    case OPC_ANDI: env->icount[394]++; break;
+    case OPC_LUI: env->icount[395]++; break;
+    case OPC_ORI: env->icount[396]++; break;
+    case OPC_XORI: env->icount[397]++; break;
+    case OPC_J: env->icount[398]++; break;
+    case OPC_JAL: env->icount[399]++; break;
+    case OPC_BEQ: env->icount[400]++; break;
+    case OPC_BEQL: env->icount[401]++; break;
+    case OPC_BNE: env->icount[402]++; break;
+    case OPC_BNEL: env->icount[403]++; break;
+    case OPC_BLEZ: env->icount[404]++; break;
+    case OPC_BLEZL: env->icount[405]++; break;
+    case OPC_BGTZ: env->icount[406]++; break;
+    case OPC_BGTZL: env->icount[407]++; break;
+    case OPC_LB: env->icount[408]++; break;
+    case OPC_LH: env->icount[409]++; break;
+    case OPC_LWL: env->icount[410]++; break;
+    case OPC_LW: env->icount[411]++; break;
+    case OPC_LWPC: env->icount[412]++; break;
+    case OPC_LBU: env->icount[413]++; break;
+    case OPC_LHU: env->icount[414]++; break;
+    case OPC_LWR: env->icount[415]++; break;
+    case OPC_LL: env->icount[416]++; break;
+    case OPC_SB: env->icount[417]++; break;
+    case OPC_SH: env->icount[418]++; break;
+    case OPC_SWL: env->icount[419]++; break;
+    case OPC_SW: env->icount[420]++; break;
+    case OPC_SWR: env->icount[421]++; break;
+    case OPC_SC: env->icount[422]++; break;
+    case OPC_CACHE: env->icount[423]++; break;
+    case OPC_PREF: env->icount[424]++; break;
+    case OPC_LWC1: env->icount[425]++; break;
+    case OPC_LDC1: env->icount[426]++; break;
+    case OPC_SWC1: env->icount[427]++; break;
+    case OPC_SDC1: env->icount[428]++; break;
+    case OPC_CP1:
+        op1 = MASK_CP1(opcode);
+        switch (op1) {
+        case OPC_MFHC1: env->icount[429]++; break;
+        case OPC_MTHC1: env->icount[430]++; break;
+        case OPC_MFC1: env->icount[431]++; break;
+        case OPC_CFC1: env->icount[432]++; break;
+        case OPC_MTC1: env->icount[433]++; break;
+        case OPC_CTC1: env->icount[434]++; break;
+        case OPC_DMFC1: env->icount[435]++; break;
+        case OPC_DMTC1: env->icount[436]++; break;
+        case OPC_BC1ANY2: env->icount[437]++; break;
+        case OPC_BC1ANY4: env->icount[438]++; break;
+        case OPC_BC1: env->icount[439]++; break;
+        case OPC_S_FMT: env->icount[440]++; break;
+        case OPC_D_FMT: env->icount[441]++; break;
+        case OPC_W_FMT: env->icount[442]++; break;
+        case OPC_L_FMT: env->icount[443]++; break;
+        case OPC_PS_FMT: env->icount[444]++; break;
+        default: env->invalid_opc++; break;
+        }
+    break;
+    case OPC_LWC2: env->icount[445]++; break;
+    case OPC_LDC2: env->icount[446]++; break;
+    case OPC_SWC2: env->icount[447]++; break;
+    case OPC_SDC2: env->icount[448]++; break;
+    case OPC_CP2: env->icount[449]++; break;
+    case OPC_CP3:
+        op1 = MASK_CP3(opcode);
+        switch (op1) {
+        case OPC_LWXC1: env->icount[450]++; break;
+        case OPC_LDXC1: env->icount[451]++; break;
+        case OPC_LUXC1: env->icount[452]++; break;
+        case OPC_SWXC1: env->icount[453]++; break;
+        case OPC_SDXC1: env->icount[454]++; break;
+        case OPC_SUXC1: env->icount[455]++; break;
+        case OPC_PREFX: env->icount[456]++; break;
+        case OPC_ALNV_PS: env->icount[457]++; break;
+        case OPC_MADD_S: env->icount[458]++; break;
+        case OPC_MADD_D: env->icount[459]++; break;
+        case OPC_MADD_PS: env->icount[460]++; break;
+        case OPC_MSUB_S: env->icount[461]++; break;
+        case OPC_MSUB_D: env->icount[462]++; break;
+        case OPC_MSUB_PS: env->icount[463]++; break;
+        case OPC_NMADD_S: env->icount[464]++; break;
+        case OPC_NMADD_D: env->icount[465]++; break;
+        case OPC_NMADD_PS: env->icount[466]++; break;
+        case OPC_NMSUB_S: env->icount[467]++; break;
+        case OPC_NMSUB_D: env->icount[468]++; break;
+        case OPC_NMSUB_PS: env->icount[469]++; break;
+        default: env->invalid_opc++; break;
+        }
+    break;
+    case OPC_LWU: env->icount[470]++; break;
+    case OPC_LDL: env->icount[471]++; break;
+    case OPC_LDR: env->icount[472]++; break;
+    case OPC_LLD: env->icount[473]++; break;
+    case OPC_LD: env->icount[474]++; break;
+    case OPC_SDL: env->icount[475]++; break;
+    case OPC_SDR: env->icount[476]++; break;
+    case OPC_SD: env->icount[477]++; break;
+    case OPC_SCD: env->icount[478]++; break;
+    case OPC_DADDI: env->icount[479]++; break;
+    case OPC_DADDIU: env->icount[480]++; break;
+    case OPC_JALX: env->icount[481]++; break;
+    case OPC_MDMX: env->icount[482]++; break;
+    default: env->invalid_opc++; break;
+    }
+}
+
 /* General purpose registers moves. */
 static inline void gen_load_gpr (TCGv t, int reg)
 {
@@ -2113,6 +2765,9 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
 {
     TCGv t0, t1, t2;
 
+    TCGv_i32 type = tcg_temp_new_i32();
+    TCGv_i32 size = tcg_temp_new_i32();
+
     if (rt == 0 && ctx->insn_flags & (INSN_LOONGSON2E | INSN_LOONGSON2F)) {
         /* Loongson CPU uses a load to zero register for prefetch.
            We emulate it as a NOP. On other CPU we must perform the
@@ -2201,11 +2856,17 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
         gen_store_gpr(t0, rt);
         break;
     case OPC_LW:
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 4);
+        DCAX(type,size,t0);
         tcg_gen_qemu_ld_tl(t0, t0, ctx->mem_idx, MO_TESL |
                            ctx->default_tcg_memop_mask);
         gen_store_gpr(t0, rt);
         break;
     case OPC_LH:
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
         tcg_gen_qemu_ld_tl(t0, t0, ctx->mem_idx, MO_TESW |
                            ctx->default_tcg_memop_mask);
         gen_store_gpr(t0, rt);
@@ -2216,10 +2877,16 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
         gen_store_gpr(t0, rt);
         break;
     case OPC_LB:
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 1);
+        DCAX(type,size,t0);
         tcg_gen_qemu_ld_tl(t0, t0, ctx->mem_idx, MO_SB);
         gen_store_gpr(t0, rt);
         break;
     case OPC_LBU:
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 1);
+        DCAX(type,size,t0);
         tcg_gen_qemu_ld_tl(t0, t0, ctx->mem_idx, MO_UB);
         gen_store_gpr(t0, rt);
         break;
@@ -2230,7 +2897,15 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
         tcg_gen_qemu_ld_tl(t1, t0, ctx->mem_idx, MO_UB);
         tcg_gen_andi_tl(t1, t0, 3);
 #ifndef TARGET_WORDS_BIGENDIAN
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
         tcg_gen_xori_tl(t1, t1, 3);
+#else
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 2);
+        tcg_gen_addi_tl(t0, t0, 2);
+        DCAX(type,size,t0);
 #endif
         tcg_gen_shli_tl(t1, t1, 3);
         tcg_gen_andi_tl(t0, t0, ~3);
@@ -2253,7 +2928,15 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
         tcg_gen_qemu_ld_tl(t1, t0, ctx->mem_idx, MO_UB);
         tcg_gen_andi_tl(t1, t0, 3);
 #ifdef TARGET_WORDS_BIGENDIAN
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 2);
+        tcg_gen_addi_tl(t0, t0, 2);
+        DCAX(type,size,t0);
         tcg_gen_xori_tl(t1, t1, 3);
+#else
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
 #endif
         tcg_gen_shli_tl(t1, t1, 3);
         tcg_gen_andi_tl(t0, t0, ~3);
@@ -2271,6 +2954,9 @@ static void gen_ld(DisasContext *ctx, uint32_t opc,
         gen_store_gpr(t0, rt);
         break;
     case OPC_LL:
+        tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+        tcg_gen_movi_tl(size, 4);
+        DCAX(type,size,t0);
     case R6_OPC_LL:
         op_ld_ll(t0, t0, ctx);
         gen_store_gpr(t0, rt);
@@ -2286,6 +2972,9 @@ static void gen_st (DisasContext *ctx, uint32_t opc, int rt,
     TCGv t0 = tcg_temp_new();
     TCGv t1 = tcg_temp_new();
 
+    TCGv_i32 type = tcg_temp_new_i32();
+    TCGv_i32 size = tcg_temp_new_i32();
+
     gen_base_offset_addr(ctx, t0, base, offset);
     gen_load_gpr(t1, rt);
     switch (opc) {
@@ -2302,20 +2991,49 @@ static void gen_st (DisasContext *ctx, uint32_t opc, int rt,
         break;
 #endif
     case OPC_SW:
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 4);
+        DCAX(type,size,t0);
         tcg_gen_qemu_st_tl(t1, t0, ctx->mem_idx, MO_TEUL |
                            ctx->default_tcg_memop_mask);
         break;
     case OPC_SH:
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
         tcg_gen_qemu_st_tl(t1, t0, ctx->mem_idx, MO_TEUW |
                            ctx->default_tcg_memop_mask);
         break;
     case OPC_SB:
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 1);
+        DCAX(type,size,t0);
         tcg_gen_qemu_st_tl(t1, t0, ctx->mem_idx, MO_8);
         break;
     case OPC_SWL:
+#ifdef TARGET_WORDS_BIGENDIAN
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        tcg_gen_addi_tl(t0, t0, 2);
+        DCAX(type,size,t0);
+#else
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
+#endif
         gen_helper_0e2i(swl, t1, t0, ctx->mem_idx);
         break;
     case OPC_SWR:
+#ifdef TARGET_WORDS_BIGENDIAN
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        tcg_gen_addi_tl(t0, t0, 2);
+        DCAX(type,size,t0);
+#else
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
+#endif
         gen_helper_0e2i(swr, t1, t0, ctx->mem_idx);
         break;
     }
@@ -2330,6 +3048,9 @@ static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,
 {
     TCGv t0, t1;
 
+    TCGv_i32 type = tcg_temp_new_i32();
+    TCGv_i32 size = tcg_temp_new_i32();
+
 #ifdef CONFIG_USER_ONLY
     t0 = tcg_temp_local_new();
     t1 = tcg_temp_local_new();
@@ -2347,6 +3068,9 @@ static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,
         break;
 #endif
     case OPC_SC:
+        tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+        tcg_gen_movi_tl(size, 2);
+        DCAX(type,size,t0);
     case R6_OPC_SC:
         op_st_sc(t1, t0, rt, ctx);
         break;
@@ -2361,12 +3085,19 @@ static void gen_flt_ldst (DisasContext *ctx, uint32_t opc, int ft,
 {
     TCGv t0 = tcg_temp_new();
 
+    TCGv_i32 type = tcg_temp_new_i32();
+    TCGv_i32 size = tcg_temp_new_i32();
+
     gen_base_offset_addr(ctx, t0, base, offset);
     /* Don't do NOP if destination is zero: we must perform the actual
        memory access. */
     switch (opc) {
     case OPC_LWC1:
         {
+
+            tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+            tcg_gen_movi_tl(size, 4);
+            DCAX(type,size,t0);
             TCGv_i32 fp0 = tcg_temp_new_i32();
             tcg_gen_qemu_ld_i32(fp0, t0, ctx->mem_idx, MO_TESL |
                                 ctx->default_tcg_memop_mask);
@@ -2376,6 +3107,9 @@ static void gen_flt_ldst (DisasContext *ctx, uint32_t opc, int ft,
         break;
     case OPC_SWC1:
         {
+            tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+            tcg_gen_movi_tl(size, 4);
+            DCAX(type,size,t0);
             TCGv_i32 fp0 = tcg_temp_new_i32();
             gen_load_fpr32(ctx, fp0, ft);
             tcg_gen_qemu_st_i32(fp0, t0, ctx->mem_idx, MO_TEUL |
@@ -2385,6 +3119,9 @@ static void gen_flt_ldst (DisasContext *ctx, uint32_t opc, int ft,
         break;
     case OPC_LDC1:
         {
+            tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+            tcg_gen_movi_tl(size, 8);
+            DCAX(type,size,t0);
             TCGv_i64 fp0 = tcg_temp_new_i64();
             tcg_gen_qemu_ld_i64(fp0, t0, ctx->mem_idx, MO_TEQ |
                                 ctx->default_tcg_memop_mask);
@@ -2394,6 +3131,9 @@ static void gen_flt_ldst (DisasContext *ctx, uint32_t opc, int ft,
         break;
     case OPC_SDC1:
         {
+            tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+            tcg_gen_movi_tl(size, 8);
+            DCAX(type,size,t0);
             TCGv_i64 fp0 = tcg_temp_new_i64();
             gen_load_fpr64(ctx, fp0, ft);
             tcg_gen_qemu_st_i64(fp0, t0, ctx->mem_idx, MO_TEQ |
@@ -7906,7 +8646,7 @@ static void gen_cp0 (CPUMIPSState *env, DisasContext *ctx, uint32_t opc, int rt,
     case OPC_MFHC0:
         check_mvh(ctx);
         if (rt == 0) {
-            /* Treat as NOP. */
+            /* Treat as NOP. */ 
             return;
         }
         gen_mfhc0(ctx, cpu_gpr[rt], rd, ctx->opcode & 0x7);
@@ -10003,6 +10743,9 @@ static void gen_flt3_ldst (DisasContext *ctx, uint32_t opc,
 {
     TCGv t0 = tcg_temp_new();
 
+    TCGv_i32 type = tcg_temp_new_i32();
+    TCGv_i32 size = tcg_temp_new_i32();
+
     if (base == 0) {
         gen_load_gpr(t0, index);
     } else if (index == 0) {
@@ -10038,6 +10781,9 @@ static void gen_flt3_ldst (DisasContext *ctx, uint32_t opc,
         check_cp1_64bitmode(ctx);
         tcg_gen_andi_tl(t0, t0, ~0x7);
         {
+            tcg_gen_movi_tl(type, MIPS_CACHE_READ);
+            tcg_gen_movi_tl(size, 8);
+            DCAX(type,size,t0);
             TCGv_i64 fp0 = tcg_temp_new_i64();
 
             tcg_gen_qemu_ld_i64(fp0, t0, ctx->mem_idx, MO_TEQ);
@@ -10048,6 +10794,9 @@ static void gen_flt3_ldst (DisasContext *ctx, uint32_t opc,
     case OPC_SWXC1:
         check_cop1x(ctx);
         {
+            tcg_gen_movi_tl(type, MIPS_CACHE_WRITE);
+            tcg_gen_movi_tl(size, 8);
+            DCAX(type,size,t0);
             TCGv_i32 fp0 = tcg_temp_new_i32();
             gen_load_fpr32(ctx, fp0, fs);
             tcg_gen_qemu_st_i32(fp0, t0, ctx->mem_idx, MO_TEUL);
@@ -18913,6 +19662,8 @@ static void decode_opc(CPUMIPSState *env, DisasContext *ctx)
     uint32_t op, op1;
     int16_t imm;
 
+    TCGv_i32 opcode = tcg_temp_new_i32();
+
     /* make sure instructions are on a word boundary */
     if (ctx->pc & 0x3) {
         env->CP0_BadVAddr = ctx->pc;
@@ -18985,8 +19736,12 @@ static void decode_opc(CPUMIPSState *env, DisasContext *ctx)
             break;
         case OPC_SYNCI:
             check_insn(ctx, ISA_MIPS32R2);
-            /* Break the TB to be able to sync copied instructions
-               immediately */
+            if (enable_mips_cache_model) {
+                tcg_gen_movi_tl(opcode, ctx->opcode);
+                gen_helper_synci_op(cpu_env, opcode);
+
+                tcg_temp_free_i32(opcode);
+            }
             ctx->bstate = BS_STOP;
             break;
         case OPC_BPOSGE32:    /* MIPS DSP branch */
@@ -19019,8 +19774,18 @@ static void decode_opc(CPUMIPSState *env, DisasContext *ctx)
         }
         break;
     case OPC_CP0:
-        check_cp0_enabled(ctx);
         op1 = MASK_CP0(ctx->opcode);
+        if (op1 == OPC_CACHE_START) {
+            if (enable_mips_cache_model || enable_mips_icount_stats)
+                gen_helper_cache_log_toggle_on(cpu_env);
+        } else if (op1 == OPC_CACHE_STOP) {
+            if (enable_mips_cache_model || enable_mips_icount_stats){
+                //printf("cpu_env adr2 = %d", &cpu_env);
+                gen_helper_cache_log_toggle_off(cpu_env);
+            }
+
+        } else {
+        check_cp0_enabled(ctx);
         switch (op1) {
         case OPC_MFC0:
         case OPC_MTC0:
@@ -19109,6 +19874,7 @@ static void decode_opc(CPUMIPSState *env, DisasContext *ctx)
             generate_exception_end(ctx, EXCP_RI);
             break;
         }
+    }
         break;
     case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */
         if (ctx->insn_flags & ISA_MIPS32R6) {
@@ -19221,12 +19987,22 @@ static void decode_opc(CPUMIPSState *env, DisasContext *ctx)
         check_insn_opc_removed(ctx, ISA_MIPS32R6);
         check_cp0_enabled(ctx);
         check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);
-        /* Treat as NOP. */
+        if (enable_mips_cache_model) {
+            tcg_gen_movi_tl(opcode, ctx->opcode);
+            gen_helper_cache_op(cpu_env, opcode);
+
+            tcg_temp_free_i32(opcode);
+        }
         break;
     case OPC_PREF:
         check_insn_opc_removed(ctx, ISA_MIPS32R6);
         check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);
-        /* Treat as NOP. */
+        if (enable_mips_cache_model) {
+            tcg_gen_movi_tl(opcode, ctx->opcode);
+            gen_helper_prefetch_op(cpu_env, opcode);
+
+            tcg_temp_free_i32(opcode);
+        }
         break;
 
     /* Floating point (COP1). */
@@ -19577,6 +20353,8 @@ void gen_intermediate_code(CPUMIPSState *env, struct TranslationBlock *tb)
     int insn_bytes;
     int is_slot;
 
+    TCGv_i32 tmp = tcg_temp_new_i32();
+   
     pc_start = tb->pc;
     next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;
     ctx.pc = pc_start;
@@ -19642,6 +20420,17 @@ void gen_intermediate_code(CPUMIPSState *env, struct TranslationBlock *tb)
         is_slot = ctx.hflags & MIPS_HFLAG_BMASK;
         if (!(ctx.hflags & MIPS_HFLAG_M16)) {
             ctx.opcode = cpu_ldl_code(env, ctx.pc);
+
+            if (enable_mips_cache_model) {
+                tcg_gen_movi_tl(tmp, ctx.pc);
+                gen_helper_icache_per_instruction(cpu_env, tmp);
+            }
+
+            if (enable_mips_icount_stats) {
+                tcg_gen_movi_tl(tmp, ctx.opcode);
+                gen_helper_instruction_count(cpu_env, tmp);
+            }
+
             insn_bytes = 4;
             decode_opc(env, &ctx);
         } else if (ctx.insn_flags & ASE_MICROMIPS) {
@@ -19888,6 +20677,7 @@ MIPSCPU *cpu_mips_init(const char *cpu_model)
     mvp_init(env, def);
 
     object_property_set_bool(OBJECT(cpu), true, "realized", NULL);
+   
 
     return cpu;
 }
diff --git a/ui/sdl.c b/ui/sdl.c
index 570cb99..6e6b08a 100644
--- a/ui/sdl.c
+++ b/ui/sdl.c
@@ -799,6 +799,37 @@ static void handle_activation(SDL_Event *ev)
     }
 }
 
+typedef struct CPUMIPSState CPUMIPSState;
+extern CPUMIPSState *env_ptr;
+extern void helper_cache_log_toggle_on(CPUMIPSState *env);
+extern void helper_cache_log_toggle_off(CPUMIPSState *env);
+
+#define IS_KEY_START_TRACE(key) (key == SDLK_QUOTE)
+#define IS_KEY_STOP_TRACE(key)  (key == SDLK_SEMICOLON)
+#define IS_KEY_MODIFIER(key)    ((key == SDLK_RCTRL) || (key == SDLK_LCTRL))
+
+static SDLKey modifier = 0;
+
+static void mips_handle_keydown(SDL_Event *ev)
+{
+    if (IS_KEY_START_TRACE(ev->key.keysym.sym) && IS_KEY_MODIFIER(modifier)) {
+        helper_cache_log_toggle_on(env_ptr);
+    }
+    if (IS_KEY_STOP_TRACE(ev->key.keysym.sym) && IS_KEY_MODIFIER(modifier)) {
+        helper_cache_log_toggle_off(env_ptr);
+    }
+    if (IS_KEY_MODIFIER(ev->key.keysym.sym)) {
+        modifier = ev->key.keysym.sym;
+    }
+}
+
+static void mips_handle_keyup(SDL_Event *ev)
+{
+    if (IS_KEY_MODIFIER(ev->key.keysym.sym)) {
+        modifier = 0;
+    }
+}
+
 static void sdl_refresh(DisplayChangeListener *dcl)
 {
     SDL_Event ev1, *ev = &ev1;
@@ -817,9 +848,11 @@ static void sdl_refresh(DisplayChangeListener *dcl)
             sdl_update(dcl, 0, 0, real_screen->w, real_screen->h);
             break;
         case SDL_KEYDOWN:
+            mips_handle_keydown(ev);
             handle_keydown(ev);
             break;
         case SDL_KEYUP:
+            mips_handle_keyup(ev);
             handle_keyup(ev);
             break;
         case SDL_QUIT:
diff --git a/vl.c b/vl.c
index 873d265..0d7af06 100644
--- a/vl.c
+++ b/vl.c
@@ -2990,6 +2990,729 @@ static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size,
     }
 }
 
+static char** str_split(char* a_str, const char *a_delim)
+{
+    char** result    = 0;
+    size_t count     = 0;
+    char* tmp        = a_str;
+    char* last_comma = 0;
+
+    /* Count how many elements will be extracted. */
+    while (*tmp)
+    {
+        if (*a_delim == *tmp)
+        {
+            count++;
+            last_comma = tmp;
+        }
+        tmp++;
+    }
+
+    /* Add space for trailing token. */
+    count += last_comma < (a_str + strlen(a_str) - 1);
+
+    /* Add space for terminating null string so caller
+       knows where the list of returned strings ends. */
+    count++;
+
+    result = malloc(sizeof(char*) * count);
+
+    if (result)
+    {
+        size_t idx  = 0;
+        char* token = strtok(a_str, a_delim);
+
+        while (token)
+        {
+            assert(idx < count);
+            *(result + idx++) = strdup(token);
+            token = strtok(0, a_delim);
+        }
+        assert(idx == count - 1);
+        *(result + idx) = 0;
+    }
+
+    return result;
+}
+
+extern int enable_mips_cache_model;
+extern int enable_mips_icount_stats;
+
+cache_model_t l1dmodel;
+cache_model_t l1imodel;
+cache_model_t l2model;
+cache_model_t l3model;
+cache_model_t subsystem;
+
+static void check_cache_params(void)
+{
+    if (l1imodel.enable) {
+        l1imodel.ways = l1imodel.ways == 0 ? 4 : l1imodel.ways;
+        l1imodel.sets = l1imodel.sets == 0 ? 256 : l1imodel.sets;
+        l1imodel.linelength = l1imodel.linelength == 0 ? 32 : l1imodel.linelength;
+        l1imodel.alg = l1imodel.alg == 0 ? 1 : l1imodel.alg;
+        l1imodel.rdal = (l1imodel.rdal == 0 && l1imodel.wral == 0) ? 1 : 0;
+        l1imodel.type = l1imodel.type == 0 ? 1 : l1imodel.type;
+    }
+
+    if (l1dmodel.enable) {
+        l1dmodel.ways = l1dmodel.ways == 0 ? 4 : l1dmodel.ways;
+        l1dmodel.sets = l1dmodel.sets == 0 ? 256 : l1dmodel.sets;
+        l1dmodel.linelength = l1dmodel.linelength == 0 ? 32 : l1dmodel.linelength;
+        l1dmodel.rdal = (l1dmodel.rdal == 0 && l1dmodel.wral == 0) ? 1 : 0;
+        l1dmodel.alg = l1dmodel.alg == 0 ? 1 : l1dmodel.alg;
+        l1dmodel.type = l1dmodel.type == 0 ? 1 : l1dmodel.type;
+    }
+
+    if (l2model.enable && (l1dmodel.enable || l1imodel.enable)) {
+        l2model.ways = l2model.ways == 0 ? 8 : l2model.ways;
+        l2model.sets = l2model.sets == 0 ? 2048 : l2model.sets;
+        l2model.linelength = l2model.linelength == 0 ? 32 : l2model.linelength;
+        l2model.rdal = (l2model.rdal == 0 && l2model.wral == 0) ? 1 : 0;
+        l2model.alg = l2model.alg == 0 ? 1 : l2model.alg;
+        l2model.type = l2model.type == 0 ? 1 : l2model.type;
+    } else if (l2model.enable) {
+        fprintf(stderr, "L1 cache level must be enabled first!\n");
+        exit(EXIT_FAILURE);
+    }
+
+    if (l3model.enable && l2model.enable) {
+        l3model.ways = l3model.ways == 0 ? 8 : l3model.ways;
+        l3model.sets = l3model.sets == 0 ? 4096 : l3model.sets;
+        l3model.linelength = l3model.linelength == 0 ? 32 : l3model.linelength;
+        l3model.rdal = (l3model.rdal == 0 && l3model.wral == 0) ? 1 : 0;
+        l3model.alg = l3model.alg == 0 ? 1 : l3model.alg;
+        l3model.type = l3model.type == 0 ? 1 : l3model.type;
+    } else if (l3model.enable) {
+        fprintf(stderr, "L2 cache level must be enabled first!\n");
+        exit(EXIT_FAILURE);
+    }
+
+}
+
+static void parse_inscount_params(const char *arguments)
+{
+    char **inscount_params = NULL;
+    char *value = NULL;
+    char *tmp_param = NULL;
+    char *tmp_arguments = NULL;
+    struct stat st;
+
+    tmp_arguments = strdup(arguments);
+    inscount_params = str_split(tmp_arguments, ",");
+
+    if (inscount_params)
+    {
+        int i;
+        for (i = 0; *(inscount_params + i); i++)
+        {
+            value = strstr(*(inscount_params + i), "=");
+
+            if ((tmp_param = strstr(*(inscount_params + i), "icountlog")) != NULL) {
+                if (value) {
+                    if (stat((value + 1), &st) == 0) {
+                        if (!S_ISDIR(st.st_mode)) {
+                            printf("\nProvide a path to a directory!\n");
+                            exit(0);
+                        }
+                        if ((value + 1)[strlen(value + 1) - 1] != '/') {
+                            if (icount_logfile_path) free(icount_logfile_path);
+                            icount_logfile_path = (char *) malloc(strlen(value + 1) + sizeof("/icount.log"));
+                            sprintf(icount_logfile_path, "%s/icount.log", (value + 1));
+                        } else {
+                            if (icount_logfile_path) free(icount_logfile_path);
+                            icount_logfile_path = (char *) malloc(strlen(value + 1) + sizeof("icount.log"));
+                            sprintf(icount_logfile_path, "%sicount.log", (value + 1));
+                        }
+                    } else {
+                        printf("\nProvide a path to the existing directory!\n");
+                        exit(0);
+                    }
+                } else {
+                    fprintf(stderr, "icountlog requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(inscount_params + i), "true")) == NULL) {
+                fprintf(stderr, "Unknown parameter! Usage : -inscount true[,icountlog=PATH]\n");
+                exit(EXIT_FAILURE);
+            }
+        }
+    }
+}
+
+static void parse_cache_params(const char *arguments)
+{
+    char **cache_params = NULL;
+    char *value = NULL;
+    char *tmp_param = NULL;
+    char *tmp_arguments = NULL;
+    long int int_val = -1;
+    struct stat st;
+
+    tmp_arguments = strdup(arguments);
+    cache_params = str_split(tmp_arguments, ",");
+
+    if (cache_params)
+    {
+        int i;
+        for (i = 0; *(cache_params + i); i++)
+        {
+            value = strstr(*(cache_params + i), "=");
+
+            if ((tmp_param = strstr(*(cache_params + i), "l1imodel")) != NULL) {
+                l1imodel.enable = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1iways")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1imodel.ways = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1iways requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1isets")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1imodel.sets = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1isets requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1ilength")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno == EINVAL && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1imodel.linelength = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1ilength requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1irdal")) != NULL) {
+                l1imodel.rdal = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1ialg")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "lru") == 0) {
+                        l1imodel.alg = 1;
+                    } else if (strcasecmp((value + 1), "rrobin") == 0) {
+                        l1imodel.alg = 2;
+                    } else if (strcasecmp((value + 1), "random") == 0) {
+                        l1imodel.alg = 3;
+                    } else if (strcasecmp((value + 1), "nmru4") == 0) {
+                        l1imodel.alg = 4;
+                    } else if (strcasecmp((value + 1), "nmru8") == 0) {
+                        l1imodel.alg = 5;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache victim selection algorithm :\n\n");
+                        fprintf(stderr, "lru\n");
+                        fprintf(stderr, "rrobin\n");
+                        fprintf(stderr, "random\n");
+                        fprintf(stderr, "nmru4\n");
+                        fprintf(stderr, "nmru8\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l1ialg argument! Type -cache l1ialg=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l1ialg requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1itype")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "VIPT") == 0) {
+                        l1imodel.type = 1;
+                    } else if (strcasecmp((value + 1), "VIVT") == 0) {
+                        l1imodel.type = 2;
+                    } else if (strcasecmp((value + 1), "PIPT") == 0) {
+                        l1imodel.type = 3;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache type :\n\n");
+                        fprintf(stderr, "VIPT\n");
+                        fprintf(stderr, "VIVT\n");
+                        fprintf(stderr, "PIPT\n\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l1itype argument! Type -cache l1itype=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l1itype requires an argument! Type -cache l1itype=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1ienops")) != NULL) {
+                l1imodel.enops = 1;
+
+            /* L1 Data cache configuration parameters */
+
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dmodel")) != NULL) {
+                l1dmodel.enable = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dways")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1dmodel.ways = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1dways requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dsets")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1dmodel.sets = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1dsets requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dlength")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno == EINVAL && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l1dmodel.linelength = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l1dlength requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1drdal")) != NULL) {
+                l1dmodel.rdal = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dwral")) != NULL) {
+                l1dmodel.wral = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dwback")) != NULL) {
+                l1dmodel.wback = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dalg")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "lru") == 0) {
+                        l1dmodel.alg = 1;
+                    } else if (strcasecmp((value + 1), "rrobin") == 0) {
+                        l1dmodel.alg = 2;
+                    } else if (strcasecmp((value + 1), "random") == 0) {
+                        l1dmodel.alg = 3;
+                    } else if (strcasecmp((value + 1), "nmru4") == 0) {
+                        l1dmodel.alg = 4;
+                    } else if (strcasecmp((value + 1), "nmru8") == 0) {
+                        l1dmodel.alg = 5;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache victim selection algorithm :\n\n");
+                        fprintf(stderr, "lru\n");
+                        fprintf(stderr, "rrobin\n");
+                        fprintf(stderr, "random\n");
+                        fprintf(stderr, "nmru4\n");
+                        fprintf(stderr, "nmru8\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l1dalg argument! Type -cache l1dalg=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l1dalg requires an argument! Type -cache l1dalg=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1dtype")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "VIPT") == 0) {
+                        l1dmodel.type = 1;
+                    } else if (strcasecmp((value + 1), "VIVT") == 0) {
+                        l1dmodel.type = 2;
+                    } else if (strcasecmp((value + 1), "PIPT") == 0) {
+                        l1dmodel.type = 3;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache type :\n\n");
+                        fprintf(stderr, "VIPT\n");
+                        fprintf(stderr, "VIVT\n");
+                        fprintf(stderr, "PIPT\n\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l1dtype argument! Type -cache l1dtype=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l1dtype requires an argument! Type -cache l1dtype=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l1denops")) != NULL) {
+                l1dmodel.enops = 1;
+
+            /* L2 Data cache configuration parameters */
+
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2model")) != NULL) {
+                l2model.enable = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2ways")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l2model.ways = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l2ways requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2sets")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l2model.sets = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l2sets requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2length")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno == EINVAL && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l2model.linelength = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l2length requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2rdal")) != NULL) {
+                l2model.rdal = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2wral")) != NULL) {
+                l2model.wral = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2wback")) != NULL) {
+                l2model.wback = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2alg")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "lru") == 0) {
+                        l2model.alg = 1;
+                    } else if (strcasecmp((value + 1), "rrobin") == 0) {
+                        l2model.alg = 2;
+                    } else if (strcasecmp((value + 1), "random") == 0) {
+                        l2model.alg = 3;
+                    } else if (strcasecmp((value + 1), "nmru4") == 0) {
+                        l2model.alg = 4;
+                    } else if (strcasecmp((value + 1), "nmru8") == 0) {
+                        l2model.alg = 5;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache victim selection algorithm :\n\n");
+                        fprintf(stderr, "lru\n");
+                        fprintf(stderr, "rrobin\n");
+                        fprintf(stderr, "random\n");
+                        fprintf(stderr, "nmru4\n");
+                        fprintf(stderr, "nmru8\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l2alg argument! Type -cache l2alg=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l2alg requires an argument! Type -cache l2alg=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2type")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "VIPT") == 0) {
+                        l2model.type = 1;
+                    } else if (strcasecmp((value + 1), "VIVT") == 0) {
+                        l2model.type = 2;
+                    } else if (strcasecmp((value + 1), "PIPT") == 0) {
+                        l2model.type = 3;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache type :\n\n");
+                        fprintf(stderr, "VIPT\n");
+                        fprintf(stderr, "VIVT\n");
+                        fprintf(stderr, "PIPT\n\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l2type argument! Type -cache l2type=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l2type requires an argument! Type -cache l2type=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l2enops")) != NULL) {
+                l2model.enops = 1;
+
+            /* L3 Data cache configuration parameters */
+
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3model")) != NULL) {
+                l3model.enable = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3ways")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l3model.ways = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l3ways requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3sets")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno != 0 && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l3model.sets = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l3sets requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3length")) != NULL) {
+                if (value) {
+                    errno = 0;
+                    int_val = strtol((value + 1), NULL, 10);
+                    if ((errno == ERANGE && (int_val == LONG_MAX || int_val == LONG_MIN)) ||
+                        (errno == EINVAL && int_val == 0)) {
+                        perror("Only integer allowed");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        l3model.linelength = (uint32_t)int_val;
+                    }
+                } else {
+                    fprintf(stderr, "l3length requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3rdal")) != NULL) {
+                l3model.rdal = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3wral")) != NULL) {
+                l3model.wral = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3wback")) != NULL) {
+                l3model.wback = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3alg")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "lru") == 0) {
+                        l3model.alg = 1;
+                    } else if (strcasecmp((value + 1), "rrobin") == 0) {
+                        l3model.alg = 2;
+                    } else if (strcasecmp((value + 1), "random") == 0) {
+                        l3model.alg = 3;
+                    } else if (strcasecmp((value + 1), "nmru4") == 0) {
+                        l3model.alg = 4;
+                    } else if (strcasecmp((value + 1), "nmru8") == 0) {
+                        l3model.alg = 5;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache victim selection algorithm :\n\n");
+                        fprintf(stderr, "lru\n");
+                        fprintf(stderr, "rrobin\n");
+                        fprintf(stderr, "random\n");
+                        fprintf(stderr, "nmru4\n");
+                        fprintf(stderr, "nmru8\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l3alg argument! Type -cache l3alg=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l3alg requires an argument! Type -cache l3alg=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3type")) != NULL) {
+                if (value) {
+                    if (strcasecmp((value + 1), "VIPT") == 0) {
+                        l3model.type = 1;
+                    } else if (strcasecmp((value + 1), "VIVT") == 0) {
+                        l3model.type = 2;
+                    } else if (strcasecmp((value + 1), "PIPT") == 0) {
+                        l3model.type = 3;
+                    } else if (strcasecmp((value + 1), "?") == 0) {
+                        fprintf(stderr, "Cache type :\n\n");
+                        fprintf(stderr, "VIPT\n");
+                        fprintf(stderr, "VIVT\n");
+                        fprintf(stderr, "PIPT\n\n");
+                        exit(EXIT_FAILURE);
+                    } else {
+                        fprintf(stderr, "Illegal l3type argument! Type -cache l3type=? for "
+                                        "available options.\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else {
+                    fprintf(stderr, "l3type requires an argument! Type -cache l3type=? for "
+                                    "available options.\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "l3enops")) != NULL) {
+                l3model.enops = 1;
+            } else if ((tmp_param = strstr(*(cache_params + i), "cachelog")) != NULL) {
+                if (value) {
+                    if (stat((value + 1), &st) == 0) {
+                        if (!S_ISDIR(st.st_mode)) {
+                            printf("\nProvide a path to a directory!\n");
+                            exit(0);
+                        }
+                        if ((value + 1)[strlen(value + 1) - 1] != '/') {
+                            if (cache_logfile_path) free(cache_logfile_path);
+                            cache_logfile_path = (char *) malloc(strlen(value + 1) + sizeof("/cache.log"));
+                            sprintf(cache_logfile_path, "%s/cache.log", (value + 1));
+                        } else {
+                            if (cache_logfile_path) free(cache_logfile_path);
+                            cache_logfile_path = (char *) malloc(strlen(value + 1) + sizeof("cache.log"));
+                            sprintf(cache_logfile_path, "%scache.log", (value + 1));
+                        }
+                    } else {
+                        printf("\nProvide a path to the existing directory!\n");
+                        exit(0);
+                    }
+                } else {
+                    fprintf(stderr, "cachelog requires an argument!\n");
+                    exit(EXIT_FAILURE);
+                }
+            } else if ((tmp_param = strstr(*(cache_params + i), "?")) != NULL) {
+                fprintf(stderr, "Cache model simulation configuration\n\n");
+                fprintf(stderr, "Available parameters (comma separated values) :\n");
+                fprintf(stderr, "\tl1imodel\t: Enable L1 instruction cache\n");
+                fprintf(stderr, "\tl1iways=VAL\t: Set number of ways.\n\t\t\t  Default(4)\n");
+                fprintf(stderr, "\tl1isets=VAL\t: Set number of sets.\n\t\t\t  Default(256)\n");
+                fprintf(stderr, "\tl1ilength=VAL\t: Set line size in bytes.\n\t\t\t  Default(32)\n");
+                fprintf(stderr, "\tl1ialg=VAL\t: Victim selection algorithm.\n\t\t\t"
+                                "  Type -cache l1ialg=? for available options.\n\t\t\t"
+                                "  Default(lru)\n");
+                fprintf(stderr, "\tl1irdal\t\t: Allocate line on Read operation. Default.\n");
+                fprintf(stderr, "\tl1iwral\t\t: Allocate line on Write operation.\n");
+                fprintf(stderr, "\tl1itype=VAL\t: Cache type.\n"
+                                "\t\t\t  Type -cache l1itype=? for available options.\n"
+                                "\t\t\t  Default(VIPT)\n");
+                fprintf(stderr, "\tl1ienops\t: Enable cache,pref,synci instruction simulation.\n"
+                                "\t\t\t  Not enabled by default.\n");
+                fprintf(stderr, "--------------------------------------------------------------------\n");
+                fprintf(stderr, "\tl1dmodel\t: Enable L1 data cache\n");
+                fprintf(stderr, "\tl1dways=VAL\t: Set number of ways.\n\t\t\t  Default(4)\n");
+                fprintf(stderr, "\tl1dsets=VAL\t: Set number of sets.\n\t\t\t  Default(256)\n");
+                fprintf(stderr, "\tl1dlength=VAL\t: Set line size in bytes.\n\t\t\t  Default(32)\n");
+                fprintf(stderr, "\tl1dalg=VAL\t: Victim selection algorithm.\n\t\t\t"
+                                "  Type -cache l1dalg=? for available options.\n\t\t\t"
+                                "  Default(lru)\n");
+                fprintf(stderr, "\tl1drdal\t\t: Allocate line on Read operation. Default.\n");
+                fprintf(stderr, "\tl1dwral\t\t: Allocate line on Write operation.\n");
+                fprintf(stderr, "\tl1dwback\t: If this option is set, write back policy is used,\n"
+                                "\t\t\t  otherwise write through is used. Default.\n");
+                fprintf(stderr, "\tl1dtype=VAL\t: Cache type.\n"
+                                "\t\t\t  Type -cache l1dtype=? for available options.\n"
+                                "\t\t\t  Default(VIPT)\n");
+                fprintf(stderr, "\tl1denops\t: Enable cache,pref,synci instruction simulation.\n"
+                                "\t\t\t  Not enabled by default.\n");
+                fprintf(stderr, "--------------------------------------------------------------------\n");
+                fprintf(stderr, "\tl2model\t\t: Enable L2 unified cache\n");
+                fprintf(stderr, "\tl2ways=VAL\t: Set number of ways.\n\t\t\t  Default(8)\n");
+                fprintf(stderr, "\tl2sets=VAL\t: Set number of sets.\n\t\t\t  Default(2048)\n");
+                fprintf(stderr, "\tl2length=VAL\t: Set line size in bytes.\n\t\t\t  Default(32)\n");
+                fprintf(stderr, "\tl2alg=VAL\t: Victim selection algorithm.\n\t\t\t"
+                                "  Type -cache l2alg=? for available options.\n\t\t\t"
+                                "  Default(lru)\n");
+                fprintf(stderr, "\tl2rdal\t\t: Allocate line on Read operation. Default.\n");
+                fprintf(stderr, "\tl2wral\t\t: Allocate line on Write operation.\n");
+                fprintf(stderr, "\tl2wback\t\t: If this option is set, write back policy is used,\n"
+                                "\t\t\t  otherwise write through is used. Default.\n");
+                fprintf(stderr, "\tl2type=VAL\t: Cache type.\n"
+                                "\t\t\t  Type -cache l2type=? for available options.\n"
+                                "\t\t\t  Default(VIPT)\n");
+                fprintf(stderr, "\tl2enops\t\t: Enable cache,pref,synci instruction simulation.\n"
+                                "\t\t\t  Not enabled by default.\n");
+                fprintf(stderr, "--------------------------------------------------------------------\n");
+                fprintf(stderr, "\tl3model\t\t: Enable L3 unified cache\n");
+                fprintf(stderr, "\tl3ways=VAL\t: Set number of ways.\n\t\t\t  Default(8)\n");
+                fprintf(stderr, "\tl3sets=VAL\t: Set number of sets.\n\t\t\t  Default(4096)\n");
+                fprintf(stderr, "\tl3length=VAL\t: Set line size in bytes.\n\t\t\t  Default(32)\n");
+                fprintf(stderr, "\tl3alg=VAL\t: Victim selection algorithm.\n\t\t\t"
+                                "  Type -cache l3alg=? for available options.\n\t\t\t"
+                                "  Default(lru)\n");
+                fprintf(stderr, "\tl3rdal\t\t: Allocate line on Read operation. Default.\n");
+                fprintf(stderr, "\tl3wral\t\t: Allocate line on Write operation.\n");
+                fprintf(stderr, "\tl3wback\t\t: If this option is set, write back policy is used,\n"
+                                "\t\t\t  otherwise write through is used. Default.\n");
+                fprintf(stderr, "\tl3type=VAL\t: Cache type.\n"
+                                "\t\t\t  Type -cache l3type=? for available options.\n"
+                                "\t\t\t  Default(VIPT)\n");
+                fprintf(stderr, "\tl3enops\t\t: Enable cache,pref,synci instruction simulation.\n"
+                                "\t\t\t  Not enabled by default.\n\n");
+                fprintf(stderr, "\n\tcachelog=PATH\t: Create cache.log to a user defined PATH.\n"
+                                "\t\t\t  Default(/tmp/cache.log)\n\n");
+                fprintf(stderr, "Example of usage :\n\n");
+                fprintf(stderr, "-cache l1imodel,l1dmodel,l1dwback,l2model,l2wback\n\n");
+                exit(1);
+            } else {
+                fprintf(stderr, "Unknown cache parameter : %s\n", *(cache_params + i));
+                exit(1);
+            }
+
+            free(*(cache_params + i));
+        }
+        free(cache_params);
+    }
+
+    if (tmp_arguments != NULL) {
+        free(tmp_arguments);
+    }
+
+    check_cache_params();
+}
+
 int main(int argc, char **argv, char **envp)
 {
     int i;
@@ -4042,6 +4765,14 @@ int main(int argc, char **argv, char **envp)
                     exit(1);
                 }
                 break;
+            case QEMU_OPTION_cache:
+                parse_cache_params(optarg);
+                enable_mips_cache_model = 1;
+                break;
+            case QEMU_OPTION_inscount:
+                parse_inscount_params(optarg);
+                enable_mips_icount_stats = 1;
+                break;
             default:
                 os_parse_cmd_args(popt->index, optarg);
             }
-- 
1.9.1

